import{P as e,m as t,a,T as n,b as s,s as o}from"./index-B0WrnB0U.js";import"./ui-BXSSuLbp.js";import"./vendor-B26fRmtd.js";import"./crypto-oqmhCI76.js";var c={};const r={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:c.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api",testnet:"https://blockstream.info/testnet/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:c.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"},bsc:{mainnet:"https://api.bscscan.com/api",apiKey:c.VITE_BSCSCAN_API_KEY||"YourBscscanAPIKey"}};const i=new class{connectedWallets=new Map;balanceCache=new Map;transactionCache=new Map;phase1FallbackActive=!1;consecutiveFailures=0;lastUpdate=null;CACHE_DURATION=12e4;TRANSACTION_CACHE_DURATION=3e5;MAX_CONSECUTIVE_FAILURES=5;RETRY_DELAY=2e3;constructor(){this.initialize()}async initialize(){try{console.log("üöÄ Initializing Enhanced Wallet Connectivity Service...");const t=e?.enableRealWallets||!1;console.log("üìä Detected Phase: "+(t?"Phase 2":"Phase 1")),t||(console.log("‚ö†Ô∏è Phase 2 wallet connectivity not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Wallet Connectivity Service initialized successfully"),console.log("üìà Current mode: "+(this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"))}catch(t){console.error("‚ùå Failed to initialize Wallet Connectivity Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 wallet fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,this.createMockWalletConnections(),console.log("‚úÖ Phase 1 wallet fallback mode activated successfully"),console.log(`üìä Created ${this.connectedWallets.size} mock wallet connections`)}catch(e){console.error("‚ùå Failed to activate Phase 1 wallet fallback:",e),this.connectedWallets.clear()}}createMockWalletConnections(){try{const e={address:"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9",network:"ethereum",provider:"mock",isConnected:!0,balances:this.createMockBalances("ethereum")},t={address:"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:"bitcoin",provider:"mock",isConnected:!0,balances:this.createMockBalances("bitcoin")};this.connectedWallets.set("mock_ethereum",e),this.connectedWallets.set("mock_bitcoin",t)}catch(e){console.error("‚ùå Error creating mock wallet connections:",e)}}createMockBalances(e){try{const a=[];return t.filter(t=>"ethereum"===e?["ethereum","usd-coin","tether"].includes(t.id):"bitcoin"===e&&"bitcoin"===t.id).forEach(t=>{a.push({tokenId:t.id,symbol:t.symbol,balance:(10*Math.random()+.1).toFixed(4),balanceUSD:t.price*(10*Math.random()+.1),network:e,address:"ethereum"===e?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",lastUpdated:new Date})}),a}catch(a){return console.error("‚ùå Error creating mock balances:",a),[]}}async connectWallet(e,t="ethereum",a="metamask"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock wallet connection"),this.getMockWalletConnection(t);try{if(console.log(`üîó Connecting to wallet: ${e} on ${t}`),!this.isValidAddress(e,t))throw new Error(`Invalid ${t} address format`);const n=await this.fetchWalletBalances(e,t),s={address:e,network:t,provider:a,isConnected:!0,balances:n},o=`${e}_${t}`;return this.connectedWallets.set(o,s),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Successfully connected wallet with ${n.length} token balances`),s}catch(n){if(console.error("‚ùå Error connecting wallet:",n),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive wallet connection failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.getMockWalletConnection(t);const e=this.getMockWalletConnection(t);if(e)return console.log("üîÑ Returning mock wallet connection due to connection failure"),e;throw new Error(`Failed to connect wallet: ${n instanceof Error?n.message:"Unknown error"}`)}}getMockWalletConnection(e){try{const t=`mock_${e}`,a=this.connectedWallets.get(t);if(a)return a;const n={address:"ethereum"===e?"0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b9":"1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",network:e,provider:"mock",isConnected:!0,balances:this.createMockBalances(e)};return this.connectedWallets.set(t,n),n}catch(t){return console.error("‚ùå Error creating mock wallet connection:",t),{address:"mock_address",network:e,provider:"mock",isConnected:!0,balances:[]}}}async fetchWalletBalances(e,t="ethereum"){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock balances"),this.createMockBalances(t);const a=`${e}_${t}`,n=this.balanceCache.get(a);if(n&&Date.now()-n.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached wallet balances"),n.balances;try{console.log(`üîÑ Fetching real balances for ${t} wallet: ${e}`);const n=[];switch(t){case"ethereum":const a=await this.fetchEthereumBalances(e);n.push(...a);break;case"bitcoin":const s=await this.fetchBitcoinBalance(e);s&&n.push(s);break;case"polygon":const o=await this.fetchPolygonBalances(e);n.push(...o);break;case"bsc":const c=await this.fetchBSCBalances(e);n.push(...c);break;default:throw new Error(`Unsupported network: ${t}`)}return this.balanceCache.set(a,{balances:n,timestamp:Date.now()}),console.log(`‚úÖ Fetched ${n.length} real balances for ${t} wallet`),n}catch(s){console.error(`‚ùå Error fetching ${t} balances:`,s),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES&&console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive balance fetch failures detected - continuing with real data only`);const e=this.balanceCache.get(a);return e?(console.log("üíæ Returning stale cached balances due to API error"),e.balances):(console.log("üîÑ No cached data available, returning empty balances"),[])}}async fetchEthereumBalances(e){const t=[],a=r.ethereum;try{const s=await fetch(`${a.mainnet}?module=account&action=balance&address=${e}&tag=latest&apikey=${a.apiKey}`),o=await s.json();if("1"===o.status){const a=(parseInt(o.result)/1e18).toString();t.push({tokenId:"ethereum",symbol:"ETH",balance:a,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}const c=await fetch(`${a.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=999999999&sort=desc&apikey=${a.apiKey}`),r=await c.json();if("1"===r.status&&r.result){const s=new Map;r.result.forEach(e=>{s.has(e.contractAddress)||s.set(e.contractAddress,{symbol:e.tokenSymbol,decimals:parseInt(e.tokenDecimal)})});for(const[o,c]of s)try{const n=await fetch(`${a.mainnet}?module=account&action=tokenbalance&contractaddress=${o}&address=${e}&tag=latest&apikey=${a.apiKey}`),s=await n.json();if("1"===s.status&&parseInt(s.result)>0){const a=(parseInt(s.result)/Math.pow(10,c.decimals)).toString();t.push({tokenId:this.getTokenIdFromSymbol(c.symbol),symbol:c.symbol,balance:a,balanceUSD:0,network:"ethereum",address:e,lastUpdated:new Date})}}catch(n){console.warn(`Error fetching balance for token ${c.symbol}:`,n)}}}catch(n){console.error("Error fetching Ethereum balances:",n)}return t}async fetchBitcoinBalance(e){try{const t=await fetch(`${r.bitcoin.mainnet}/address/${e}`),a=await t.json();if(a.chain_stats){return{tokenId:"bitcoin",symbol:"BTC",balance:(a.chain_stats.funded_txo_sum/1e8).toString(),balanceUSD:0,network:"bitcoin",address:e,lastUpdated:new Date}}}catch(t){console.error("Error fetching Bitcoin balance:",t)}return null}async fetchPolygonBalances(e){return console.log("Polygon balance fetching not fully implemented yet"),[]}async fetchBSCBalances(e){return console.log("BSC balance fetching not fully implemented yet"),[]}isValidAddress(e,t){switch(t){case"ethereum":case"polygon":case"bsc":return/^0x[a-fA-F0-9]{40}$/.test(e);case"bitcoin":return/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(e)||/^bc1[a-z0-9]{39,59}$/.test(e);default:return!1}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}getConnectedWallets(){return Array.from(this.connectedWallets.values())}disconnectWallet(e,t){const a=`${e}_${t}`;return this.connectedWallets.delete(a)}clearCaches(){this.balanceCache.clear(),this.transactionCache.clear()}getStatus(){return{connectedWalletsCount:this.connectedWallets.size,lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,balanceCacheSize:this.balanceCache.size,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon","bsc"]}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 wallet fallback mode...");try{this.phase1FallbackActive=!1,this.consecutiveFailures=0;return Array.from(this.connectedWallets.keys()).filter(e=>e.startsWith("mock_")).forEach(e=>this.connectedWallets.delete(e)),console.log("‚úÖ Successfully recovered from wallet fallback mode"),console.log("üí° Real wallet connections can now be attempted"),!0}catch(e){return console.error("‚ùå Error during wallet recovery attempt:",e),this.activatePhase1Fallback(),!1}}getTotalBalanceUSD(){try{let e=0;return this.connectedWallets.forEach(t=>{t.balances.forEach(t=>{e+=t.balanceUSD})}),e}catch(e){return console.error("‚ùå Error calculating total balance:",e),0}}getTokenBalanceAcrossWallets(e){try{const t=[];return this.connectedWallets.forEach(a=>{const n=a.balances.find(t=>t.tokenId===e);n&&t.push(n)}),t}catch(t){return console.error("‚ùå Error getting token balances across wallets:",t),[]}}destroy(){try{this.connectedWallets.clear(),this.clearCaches(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Wallet Connectivity Service destroyed")}catch(e){console.error("‚ùå Error during wallet service cleanup:",e)}}};var l={};const h={ethereum:{mainnet:"https://api.etherscan.io/api",apiKey:l.VITE_ETHERSCAN_API_KEY||"YourEtherscanAPIKey"},bitcoin:{mainnet:"https://blockstream.info/api"},polygon:{mainnet:"https://api.polygonscan.com/api",apiKey:l.VITE_POLYGONSCAN_API_KEY||"YourPolygonscanAPIKey"}};const d=new class{transactionCache=new Map;phase1FallbackActive=!1;consecutiveFailures=0;lastUpdate=null;CACHE_DURATION=3e5;MAX_CONSECUTIVE_FAILURES=5;RETRY_DELAY=2e3;constructor(){this.initialize()}async initialize(){try{console.log("üöÄ Initializing Enhanced Real Transaction Service...");const t=e?.enableRealTransactions||!1;console.log("üìä Detected Phase: "+(t?"Phase 2":"Phase 1")),t||(console.log("‚ö†Ô∏è Phase 2 real transactions not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Real Transaction Service initialized successfully"),console.log("üìà Current mode: "+(this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"))}catch(t){console.error("‚ùå Failed to initialize Real Transaction Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 transaction fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Phase 1 transaction fallback mode activated successfully"),console.log(`üìä Using ${a.length} mock transactions`)}catch(e){console.error("‚ùå Failed to activate Phase 1 transaction fallback:",e)}}async fetchTransactionHistory(e,t="ethereum",a=50){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock transactions"),this.createMockTransactionsForAddress(e,t,a);const n=`${e}_${t}_${a}`,s=this.transactionCache.get(n);if(s&&Date.now()-s.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached transaction history"),s.transactions;try{console.log(`üîÑ Fetching real transaction history for ${t} wallet: ${e}`);let s=[];switch(t){case"ethereum":s=await this.fetchEthereumTransactions(e,a);break;case"bitcoin":s=await this.fetchBitcoinTransactions(e,a);break;case"polygon":s=await this.fetchPolygonTransactions(e,a);break;default:return console.warn(`‚ö†Ô∏è Transaction fetching not implemented for network: ${t}`),this.createMockTransactionsForAddress(e,t,a)}return this.transactionCache.set(n,{transactions:s,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Fetched ${s.length} real transactions for ${t}`),s}catch(o){if(console.error(`‚ùå Error fetching transaction history for ${t}:`,o),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive transaction fetch failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockTransactionsForAddress(e,t,a);const s=this.transactionCache.get(n);return s?(console.log("üíæ Returning stale cached transactions due to API error"),s.transactions):(console.log("üîÑ No cached data available, returning mock transactions"),this.createMockTransactionsForAddress(e,t,a))}}createMockTransactionsForAddress(e,t,n){try{const s=[];return a.slice(0,n).forEach((a,n)=>{const o=Math.random()>.5;s.push({id:`${e}_${t}_${n}`,hash:`0x${Math.random().toString(16).substr(2,64)}`,from:o?`0x${Math.random().toString(16).substr(2,40)}`:e,to:o?e:`0x${Math.random().toString(16).substr(2,40)}`,value:(10*Math.random()+.01).toFixed(4),tokenSymbol:"bitcoin"===t?"BTC":"ETH",tokenId:"bitcoin"===t?"bitcoin":"ethereum",timestamp:new Date(Date.now()-30*Math.random()*24*60*60*1e3),blockNumber:Math.floor(1e6*Math.random())+18e6,gasUsed:Math.floor(1e5*Math.random())+21e3,gasPrice:Math.floor(50*Math.random())+10,status:Math.random()>.1?"confirmed":"pending",network:t,type:o?"receive":"send"})}),s.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime())}catch(s){return console.error("‚ùå Error creating mock transactions:",s),[]}}async fetchEthereumTransactions(e,t){const a=[],n=h.ethereum;try{const s=await fetch(`${n.mainnet}?module=account&action=txlist&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${n.apiKey}`),o=await s.json();if("1"===o.status&&o.result)for(const t of o.result)a.push({id:t.hash,hash:t.hash,from:t.from,to:t.to,value:(parseInt(t.value)/1e18).toString(),tokenSymbol:"ETH",tokenId:"ethereum",timestamp:new Date(1e3*parseInt(t.timeStamp)),blockNumber:parseInt(t.blockNumber),gasUsed:t.gasUsed,gasPrice:t.gasPrice,status:"1"===t.txreceipt_status?"confirmed":"failed",network:"ethereum",type:t.from.toLowerCase()===e.toLowerCase()?"send":"receive"});const c=await fetch(`${n.mainnet}?module=account&action=tokentx&address=${e}&startblock=0&endblock=99999999&page=1&offset=${t}&sort=desc&apikey=${n.apiKey}`),r=await c.json();if("1"===r.status&&r.result)for(const t of r.result){const n=parseInt(t.tokenDecimal),s=(parseInt(t.value)/Math.pow(10,n)).toString();a.push({id:`${t.hash}_${t.tokenSymbol}`,hash:t.hash,from:t.from,to:t.to,value:s,tokenSymbol:t.tokenSymbol,tokenId:this.getTokenIdFromSymbol(t.tokenSymbol),timestamp:new Date(1e3*parseInt(t.timeStamp)),blockNumber:parseInt(t.blockNumber),gasUsed:t.gasUsed,gasPrice:t.gasPrice,status:"confirmed",network:"ethereum",type:t.from.toLowerCase()===e.toLowerCase()?"send":"receive"})}}catch(s){console.error("Error fetching Ethereum transactions:",s)}return a.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime()).slice(0,t)}async fetchBitcoinTransactions(e,t){const a=[];try{const n=await fetch(`${h.bitcoin.mainnet}/address/${e}/txs`),s=await n.json();if(Array.isArray(s))for(const o of s.slice(0,t)){const t=o.vout.some(t=>t.scriptpubkey_address===e),n=o.vin.some(t=>t.prevout&&t.prevout.scriptpubkey_address===e);let s="0",c="receive";if(t&&!n){s=(o.vout.find(t=>t.scriptpubkey_address===e).value/1e8).toString(),c="receive"}else if(n){s=(o.vin.filter(t=>t.prevout&&t.prevout.scriptpubkey_address===e).reduce((e,t)=>e+t.prevout.value,0)/1e8).toString(),c="send"}a.push({id:o.txid,hash:o.txid,from:"send"===c?e:"unknown",to:"receive"===c?e:"unknown",value:s,tokenSymbol:"BTC",tokenId:"bitcoin",timestamp:new Date(1e3*o.status.block_time),blockNumber:o.status.block_height,gasUsed:o.fee.toString(),gasPrice:"0",status:o.status.confirmed?"confirmed":"pending",network:"bitcoin",type:c})}}catch(n){console.error("Error fetching Bitcoin transactions:",n)}return a}async fetchPolygonTransactions(e,t){return console.log("Polygon transaction fetching not fully implemented yet"),[]}convertToAppTransactions(e){return e.map(e=>{const t={id:e.id,type:this.mapTransactionType(e.type),status:this.mapTransactionStatus(e.status),timestamp:e.timestamp.getTime(),hash:e.hash,account:e.from,from:e.from,to:e.to,fee:e.gasUsed,chain:e.network};return"send"===e.type?(t.fromAmount=e.value,t.amount=e.value):"receive"===e.type?(t.toAmount=e.value,t.amount=e.value):t.amount=e.value,t})}mapTransactionType(e){switch(e){case"send":default:return n.SEND;case"receive":return n.RECEIVE;case"swap":return n.SWAP;case"stake":return n.STAKE;case"unstake":return n.UNSTAKE}}mapTransactionStatus(e){switch(e){case"confirmed":return s.COMPLETED;case"pending":default:return s.PENDING;case"failed":return s.FAILED}}getTokenIdFromSymbol(e){return{ETH:"ethereum",BTC:"bitcoin",USDC:"usd-coin",USDT:"tether",BNB:"binancecoin",MATIC:"matic-network",SOL:"solana",ADA:"cardano",XRP:"ripple"}[e.toUpperCase()]||e.toLowerCase()}async getAllWalletTransactions(e=100){try{if(console.log("üîÑ Fetching transaction history for all connected wallets..."),this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const a=i.getConnectedWallets();if(0===a.length)return console.log("‚ö†Ô∏è No connected wallets found, returning mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e));const n=[];for(const o of a)try{const t=await this.fetchTransactionHistory(o.address,o.network,Math.ceil(e/a.length));n.push(...t)}catch(t){console.error(`‚ùå Error fetching transactions for wallet ${o.address}:`,t);const s=this.createMockTransactionsForAddress(o.address,o.network,Math.ceil(e/a.length));n.push(...s)}const s=n.sort((e,t)=>t.timestamp.getTime()-e.timestamp.getTime()).slice(0,e);return console.log(`‚úÖ Retrieved ${s.length} transactions from ${a.length} wallets`),this.convertToAppTransactions(s)}catch(t){return console.error("‚ùå Error in getAllWalletTransactions:",t),console.log("üîÑ Falling back to mock transactions"),this.convertToAppTransactions(this.createMockTransactionsForAddress("mock_address","ethereum",e))}}getStatus(){return{lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,transactionCacheSize:this.transactionCache.size,supportedNetworks:["ethereum","bitcoin","polygon"],cacheEntries:Array.from(this.transactionCache.keys())}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 transaction fallback mode...");try{this.phase1FallbackActive=!1,this.consecutiveFailures=0;const e=i.getConnectedWallets();if(e.length>0){const t=e[0];await this.fetchTransactionHistory(t.address,t.network,1)}return console.log("‚úÖ Successfully recovered from transaction fallback mode"),!0}catch(e){return console.error("‚ùå Error during transaction recovery attempt:",e),this.activatePhase1Fallback(),!1}}clearCache(){this.transactionCache.clear(),console.log("üßπ Transaction cache cleared")}destroy(){try{this.clearCache(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Real Transaction Service destroyed")}catch(e){console.error("‚ùå Error during transaction service cleanup:",e)}}},u=[{id:"defi",name:"DeFi",color:"#34C759",icon:"TrendingUp",description:"Decentralized Finance activities"},{id:"trading",name:"Trading",color:"#FF9500",icon:"BarChart3",description:"Buy, sell, and swap transactions"},{id:"transfer",name:"Transfer",color:"#007AFF",icon:"ArrowUpDown",description:"Send and receive transactions"},{id:"payment",name:"Payment",color:"#FF3B30",icon:"CreditCard",description:"Payment transactions"},{id:"staking",name:"Staking",color:"#5856D6",icon:"Coins",description:"Staking and rewards"},{id:"other",name:"Other",color:"#8E8E93",icon:"MoreHorizontal",description:"Other transaction types"}],m=[{id:"date",label:"Date",required:!0},{id:"type",label:"Type",required:!0},{id:"token",label:"Token",required:!0},{id:"amount",label:"Amount",required:!0},{id:"value_usd",label:"Value (USD)",required:!1},{id:"status",label:"Status",required:!0},{id:"category",label:"Category",required:!1},{id:"hash",label:"Transaction Hash",required:!1},{id:"wallet_id",label:"Wallet ID",required:!1},{id:"gas_fee",label:"Gas Fee",required:!1},{id:"from_address",label:"From Address",required:!1},{id:"to_address",label:"To Address",required:!1}];new class{phase1FallbackActive=!1;consecutiveFailures=0;lastUpdate=null;analyticsCache=new Map;MAX_CONSECUTIVE_FAILURES=5;CACHE_DURATION=6e5;RETRY_DELAY=2e3;constructor(){this.initialize()}async initialize(){try{console.log("üöÄ Initializing Enhanced Transaction Analytics Service...");const t=e?.enableRealTransactions||!1;console.log("üìä Detected Phase: "+(t?"Phase 2":"Phase 1")),t||(console.log("‚ö†Ô∏è Phase 2 enhanced analytics not enabled, activating Phase 1 fallback"),this.activatePhase1Fallback()),console.log("‚úÖ Enhanced Transaction Analytics Service initialized successfully"),console.log("üìà Current mode: "+(this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active"))}catch(t){console.error("‚ùå Failed to initialize Enhanced Transaction Analytics Service:",t),console.log("üîÑ Activating Phase 1 fallback mode for stability"),this.activatePhase1Fallback()}}activatePhase1Fallback(){try{console.log("üîÑ Activating Phase 1 enhanced analytics fallback mode..."),this.phase1FallbackActive=!0,this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Phase 1 enhanced analytics fallback mode activated successfully"),console.log(`üìä Using mock analytics based on ${a.length} mock transactions`)}catch(e){console.error("‚ùå Failed to activate Phase 1 enhanced analytics fallback:",e)}}createMockAnalytics(e,t={}){try{const e=a.slice(0,50);let t=0;const n={},s={},o={};e.forEach(e=>{const a=parseFloat(e.amount||"0")*(100*Math.random()+50);t+=a;const c=this.categorizeTransaction(e);n[c]=(n[c]||0)+a;const r=Math.floor(6*Math.random()),i=new Date;i.setMonth(i.getMonth()-r);const l=i.toISOString().slice(0,7);s[l]=(s[l]||0)+a;const h=e.fromToken||"ethereum";o[h]||(o[h]={volume:0,count:0}),o[h].volume+=a,o[h].count+=1});const c=e.length,r=c>0?t/c:0,i=Object.entries(s).map(([e,t])=>({month:e,volume:t})).sort((e,t)=>e.month.localeCompare(t.month)),l=Object.entries(o).map(([e,t])=>({tokenId:e,...t})).sort((e,t)=>t.volume-e.volume).slice(0,10);return{totalTransactions:c,totalVolume:t,averageAmount:r,categoryBreakdown:n,monthlyVolume:i,topTokens:l}}catch(n){return console.error("‚ùå Error creating mock analytics:",n),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]}}}async getFilteredTransactions(e,t={},a={page:1,limit:20}){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock filtered transactions"),this.createMockFilteredTransactions(e,t,a);const n=`filtered_${e}_${JSON.stringify(t)}_${JSON.stringify(a)}`,s=this.analyticsCache.get(n);if(s&&Date.now()-s.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached filtered transactions"),s.data;try{console.log("üîÑ Fetching real filtered transactions...");const s=await d.getAllWalletTransactions(a.limit);if(s&&s.length>0){const e={transactions:s.slice(0,a.limit),total:s.length};return this.analyticsCache.set(n,{data:e,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Retrieved ${e.transactions.length} real filtered transactions`),e}const o=await g(e,t,a);return this.analyticsCache.set(n,{data:o,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log(`‚úÖ Retrieved ${o.transactions.length} filtered transactions from Supabase`),o}catch(o){if(console.error("‚ùå Error fetching filtered transactions:",o),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive analytics failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockFilteredTransactions(e,t,a);const s=this.analyticsCache.get(n);return s?(console.log("üíæ Returning stale cached filtered transactions due to error"),s.data):(console.log("üîÑ No cached data available, returning mock filtered transactions"),this.createMockFilteredTransactions(e,t,a))}}createMockFilteredTransactions(e,t={},n={page:1,limit:20}){try{let e=[...a];t.transactionType&&(e=e.filter(e=>e.type===t.transactionType)),t.status&&(e=e.filter(e=>e.status===t.status)),t.tokenFilter&&(e=e.filter(e=>e.fromToken?.toLowerCase().includes(t.tokenFilter.toLowerCase())||e.toToken?.toLowerCase().includes(t.tokenFilter.toLowerCase())));const s=(n.page-1)*n.limit,o=s+n.limit;return{transactions:e.slice(s,o),total:e.length}}catch(s){return console.error("‚ùå Error creating mock filtered transactions:",s),{transactions:[],total:0}}}async getTransactionAnalytics(e,t={}){if(this.phase1FallbackActive)return console.log("üìä Phase 1 fallback mode active, returning mock analytics"),this.createMockAnalytics(e,t);const a=`analytics_${e}_${JSON.stringify(t)}`,n=this.analyticsCache.get(a);if(n&&Date.now()-n.timestamp<this.CACHE_DURATION)return console.log("üíæ Returning cached analytics"),n.data;try{console.log("üîÑ Fetching real transaction analytics...");const n=await p(e,t);return this.analyticsCache.set(a,{data:n,timestamp:Date.now()}),this.consecutiveFailures=0,this.lastUpdate=new Date,console.log("‚úÖ Retrieved real transaction analytics"),n}catch(s){if(console.error("‚ùå Error fetching transaction analytics:",s),this.consecutiveFailures++,this.consecutiveFailures>=this.MAX_CONSECUTIVE_FAILURES)return console.log(`‚ö†Ô∏è ${this.consecutiveFailures} consecutive analytics failures detected, activating Phase 1 fallback`),this.activatePhase1Fallback(),this.createMockAnalytics(e,t);const n=this.analyticsCache.get(a);return n?(console.log("üíæ Returning stale cached analytics due to error"),n.data):(console.log("üîÑ No cached data available, returning mock analytics"),this.createMockAnalytics(e,t))}}categorizeTransaction(e){switch(e.type?.toLowerCase()||e.transaction_type?.toLowerCase()){case"stake":case"unstake":case"claim_rewards":return"staking";case"swap":case"buy":case"sell":return"trading";case"send":case"receive":return"transfer";case"payment":return"payment";case"liquidity_add":case"liquidity_remove":case"yield_farm":return"defi";default:return"other"}}getStatus(){return{lastUpdate:this.lastUpdate,phase1FallbackActive:this.phase1FallbackActive,consecutiveFailures:this.consecutiveFailures,currentMode:this.phase1FallbackActive?"Phase 1 Fallback":"Phase 2 Active",isPhase2Enabled:!1,analyticsCacheSize:this.analyticsCache.size,supportedFeatures:["filtering","analytics","categorization","export"],cacheEntries:Array.from(this.analyticsCache.keys())}}isInFallbackMode(){return this.phase1FallbackActive}async attemptRecovery(){if(!this.phase1FallbackActive)return console.log("üìä Not in fallback mode, no recovery needed"),!0;console.log("üîÑ Attempting recovery from Phase 1 enhanced analytics fallback mode...");try{return this.phase1FallbackActive=!1,this.consecutiveFailures=0,await this.getTransactionAnalytics("test_user",{}),console.log("‚úÖ Successfully recovered from enhanced analytics fallback mode"),!0}catch(e){return console.error("‚ùå Error during enhanced analytics recovery attempt:",e),this.activatePhase1Fallback(),!1}}clearCache(){this.analyticsCache.clear(),console.log("üßπ Enhanced analytics cache cleared")}destroy(){try{this.clearCache(),this.phase1FallbackActive=!1,this.consecutiveFailures=0,console.log("üßπ Enhanced Transaction Analytics Service destroyed")}catch(e){console.error("‚ùå Error during enhanced analytics service cleanup:",e)}}};const g=async(e,t={},a={page:1,limit:20})=>{try{let n=o.from("transactions").select("\n        *,\n        tokens:from_token_id (\n          id,\n          symbol,\n          name,\n          logo,\n          decimals,\n          price\n        )\n      ",{count:"exact"}).eq("user_id",e);t.walletId&&(n=n.eq("wallet_id",t.walletId)),t.transactionType&&(n=n.eq("transaction_type",t.transactionType)),t.status&&(n=n.eq("status",t.status)),t.tokenId&&(n=n.eq("from_token_id",t.tokenId)),t.dateRange?n=n.gte("timestamp",t.dateRange.from.toISOString()).lte("timestamp",t.dateRange.to.toISOString()):(t.dateFrom&&(n=n.gte("timestamp",t.dateFrom)),t.dateTo&&(n=n.lte("timestamp",t.dateTo))),t.tokenFilter&&(n=n.or(`tokens.symbol.ilike.%${t.tokenFilter}%,tokens.name.ilike.%${t.tokenFilter}%`)),t.amountMin&&(n=n.gte("from_amount",t.amountMin.toString())),t.amountMax&&(n=n.lte("from_amount",t.amountMax.toString())),t.category&&(n=n.eq("category",t.category));const s=(a.page-1)*a.limit;n=n.order("timestamp",{ascending:!1}).range(s,s+a.limit-1);const{data:c,error:r,count:i}=await n;return r?(console.error("Error fetching filtered transactions:",r),{transactions:[],total:0}):{transactions:c||[],total:i||0}}catch(n){return console.error("Error in getFilteredTransactions:",n),{transactions:[],total:0}}},p=async(e,t={})=>{try{let a=o.from("transactions").select("\n        *,\n        tokens:from_token_id (\n          id,\n          symbol,\n          name,\n          price\n        )\n      ").eq("user_id",e);t.walletId&&(a=a.eq("wallet_id",t.walletId)),t.dateFrom&&(a=a.gte("timestamp",t.dateFrom)),t.dateTo&&(a=a.lte("timestamp",t.dateTo));const{data:n,error:s}=await a;if(s||!n)return console.error("Error fetching transaction analytics:",s),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]};const c=n.length;let r=0;const i={},l={},h={};n.forEach(e=>{const t=parseFloat(e.from_amount||"0")*(e.tokens?.price||0);r+=t;const a=e.category||"other";i[a]=(i[a]||0)+t;const n=new Date(e.timestamp).toISOString().slice(0,7);l[n]=(l[n]||0)+t;const s=e.from_token_id;s&&(h[s]||(h[s]={volume:0,count:0,symbol:e.tokens?.symbol||"Unknown"}),h[s].volume+=t,h[s].count+=1)});const d=c>0?r/c:0,u=Object.entries(l).map(([e,t])=>({month:e,volume:t})).sort((e,t)=>e.month.localeCompare(t.month)),m=Object.entries(h).map(([e,t])=>({tokenId:e,...t})).sort((e,t)=>t.volume-e.volume).slice(0,10);return{totalTransactions:c,totalVolume:r,averageAmount:d,categoryBreakdown:i,monthlyVolume:u,topTokens:m}}catch(a){return console.error("Error in getTransactionAnalytics:",a),{totalTransactions:0,totalVolume:0,averageAmount:0,categoryBreakdown:{},monthlyVolume:[],topTokens:[]}}},k=e=>{const t=e.transaction_type?.toLowerCase();switch(t){case"stake":case"unstake":case"claim_rewards":return"staking";case"swap":case"buy":case"sell":return"trading";case"send":case"receive":return"transfer";case"payment":return"payment";case"liquidity_add":case"liquidity_remove":case"yield_farm":return"defi";default:return"other"}},y=async(e,t)=>{try{let a={};if("custom"===t.dateRange&&t.customDateRange)a.dateRange=t.customDateRange;else{const e=new Date,n=new Date;switch(t.dateRange){case"last30days":n.setDate(e.getDate()-30);break;case"last90days":n.setDate(e.getDate()-90);break;case"alltime":n.setFullYear(2020)}a.dateRange={from:n,to:e}}const{transactions:n}=await g(e,a,{page:1,limit:1e4}),s=t.includeFields.map(e=>{const t=m.find(t=>t.id===e);return t?.label||e}),o=n.map(e=>t.includeFields.map(t=>{switch(t){case"date":return new Date(e.timestamp).toLocaleDateString();case"type":return e.transaction_type||"Unknown";case"token":return e.tokens?.symbol||"Unknown";case"amount":return e.from_amount||"0";case"value_usd":return(parseFloat(e.from_amount||"0")*(e.tokens?.price||0)).toFixed(2);case"status":return e.status||"Unknown";case"category":{const t=k(e),a=u.find(e=>e.id===t);return a?.name||"Other"}case"hash":return e.hash||"";case"wallet_id":return e.wallet_id||"";case"gas_fee":return e.gas_fee||"0";case"from_address":return e.from_address||"";case"to_address":return e.to_address||"";default:return""}}));return[s,...o].map(e=>e.map(e=>`"${e}"`).join(",")).join("\n")}catch(a){throw console.error("Error exporting transactions to CSV:",a),new Error("Failed to export transactions")}};export{m as EXPORT_FIELDS,u as TRANSACTION_CATEGORIES,k as categorizeTransaction,y as exportTransactionsToCSV,g as getFilteredTransactions,p as getTransactionAnalytics};
