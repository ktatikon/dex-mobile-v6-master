import {
  BigNumber,
  Logger,
  arrayify,
  concat,
  getAddress,
  hexZeroPad,
  require_sha3
} from "./chunk-FT3XOO7O.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports, module) {
    function toFormat2(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat3(dp, rm, fmt) {
        if (!this.e && this.e !== 0) return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u) dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u) gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u) gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u) sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1) intp += gsep + intd.substr(i, g1);
            if (g2 > 0) intp += gsep + intd.slice(i);
            if (this.s < 0) intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u) fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u) fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module !== "undefined" && module.exports) module.exports = toFormat2;
  }
});

// node_modules/jsbi/dist/jsbi.mjs
var JSBI = class _JSBI extends Array {
  constructor(i, _) {
    if (super(i), this.sign = _, i > _JSBI.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i) {
    var _ = Math.floor, t = Number.isFinite;
    if ("number" == typeof i) {
      if (0 === i) return _JSBI.__zero();
      if (_JSBI.__isOneDigitInt(i)) return 0 > i ? _JSBI.__oneDigit(-i, true) : _JSBI.__oneDigit(i, false);
      if (!t(i) || _(i) !== i) throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
      return _JSBI.__fromDouble(i);
    }
    if ("string" == typeof i) {
      const _2 = _JSBI.__fromString(i);
      if (null === _2) throw new SyntaxError("Cannot convert " + i + " to a BigInt");
      return _2;
    }
    if ("boolean" == typeof i) return true === i ? _JSBI.__oneDigit(1, false) : _JSBI.__zero();
    if ("object" == typeof i) {
      if (i.constructor === _JSBI) return i;
      const _2 = _JSBI.__toPrimitive(i);
      return _JSBI.BigInt(_2);
    }
    throw new TypeError("Cannot convert " + i + " to a BigInt");
  }
  toDebugString() {
    const i = ["BigInt["];
    for (const _ of this) i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
    return i.push("]"), i.join("");
  }
  toString(i = 10) {
    if (2 > i || 36 < i) throw new RangeError("toString() radix argument must be between 2 and 36");
    return 0 === this.length ? "0" : 0 == (i & i - 1) ? _JSBI.__toStringBasePowerOfTwo(this, i) : _JSBI.__toStringGeneric(this, i, false);
  }
  static toNumber(i) {
    const _ = i.length;
    if (0 === _) return 0;
    if (1 === _) {
      const _2 = i.__unsignedDigit(0);
      return i.sign ? -_2 : _2;
    }
    const t = i.__digit(_ - 1), e = _JSBI.__clz30(t), n = 30 * _ - e;
    if (1024 < n) return i.sign ? -Infinity : 1 / 0;
    let g = n - 1, o = t, s = _ - 1;
    const l = e + 3;
    let r = 32 === l ? 0 : o << l;
    r >>>= 12;
    const a = l - 12;
    let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
    for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; ) s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
    const h = _JSBI.__decideRounding(i, d, s, o);
    if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g)))) return i.sign ? -Infinity : 1 / 0;
    const m = i.sign ? -2147483648 : 0;
    return g = g + 1023 << 20, _JSBI.__kBitConversionInts[1] = m | g | r, _JSBI.__kBitConversionInts[0] = u, _JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i) {
    if (0 === i.length) return i;
    const _ = i.__copy();
    return _.sign = !i.sign, _;
  }
  static bitwiseNot(i) {
    return i.sign ? _JSBI.__absoluteSubOne(i).__trim() : _JSBI.__absoluteAddOne(i, true);
  }
  static exponentiate(i, _) {
    if (_.sign) throw new RangeError("Exponent must be positive");
    if (0 === _.length) return _JSBI.__oneDigit(1, false);
    if (0 === i.length) return i;
    if (1 === i.length && 1 === i.__digit(0)) return i.sign && 0 == (1 & _.__digit(0)) ? _JSBI.unaryMinus(i) : i;
    if (1 < _.length) throw new RangeError("BigInt too big");
    let t = _.__unsignedDigit(0);
    if (1 === t) return i;
    if (t >= _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
    if (1 === i.length && 2 === i.__digit(0)) {
      const _2 = 1 + (0 | t / 30), e2 = i.sign && 0 != (1 & t), n2 = new _JSBI(_2, e2);
      n2.__initializeDigits();
      const g = 1 << t % 30;
      return n2.__setDigit(_2 - 1, g), n2;
    }
    let e = null, n = i;
    for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1) n = _JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = _JSBI.multiply(e, n));
    return e;
  }
  static multiply(_, t) {
    if (0 === _.length) return _;
    if (0 === t.length) return t;
    let i = _.length + t.length;
    30 <= _.__clzmsd() + t.__clzmsd() && i--;
    const e = new _JSBI(i, _.sign !== t.sign);
    e.__initializeDigits();
    for (let n = 0; n < _.length; n++) _JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
    return e.__trim();
  }
  static divide(i, _) {
    if (0 === _.length) throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i, _)) return _JSBI.__zero();
    const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
    let n;
    if (1 === _.length && 32767 >= e) {
      if (1 === e) return t === i.sign ? i : _JSBI.unaryMinus(i);
      n = _JSBI.__absoluteDivSmall(i, e, null);
    } else n = _JSBI.__absoluteDivLarge(i, _, true, false);
    return n.sign = t, n.__trim();
  }
  static remainder(i, _) {
    if (0 === _.length) throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i, _)) return i;
    const t = _.__unsignedDigit(0);
    if (1 === _.length && 32767 >= t) {
      if (1 === t) return _JSBI.__zero();
      const _2 = _JSBI.__absoluteModSmall(i, t);
      return 0 === _2 ? _JSBI.__zero() : _JSBI.__oneDigit(_2, i.sign);
    }
    const e = _JSBI.__absoluteDivLarge(i, _, false, true);
    return e.sign = i.sign, e.__trim();
  }
  static add(i, _) {
    const t = i.sign;
    return t === _.sign ? _JSBI.__absoluteAdd(i, _, t) : 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t);
  }
  static subtract(i, _) {
    const t = i.sign;
    return t === _.sign ? 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t) : _JSBI.__absoluteAdd(i, _, t);
  }
  static leftShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__rightShiftByAbsolute(i, _) : _JSBI.__leftShiftByAbsolute(i, _);
  }
  static signedRightShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__leftShiftByAbsolute(i, _) : _JSBI.__rightShiftByAbsolute(i, _);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i, _) {
    return 0 > _JSBI.__compareToBigInt(i, _);
  }
  static lessThanOrEqual(i, _) {
    return 0 >= _JSBI.__compareToBigInt(i, _);
  }
  static greaterThan(i, _) {
    return 0 < _JSBI.__compareToBigInt(i, _);
  }
  static greaterThanOrEqual(i, _) {
    return 0 <= _JSBI.__compareToBigInt(i, _);
  }
  static equal(_, t) {
    if (_.sign !== t.sign) return false;
    if (_.length !== t.length) return false;
    for (let e = 0; e < _.length; e++) if (_.__digit(e) !== t.__digit(e)) return false;
    return true;
  }
  static notEqual(i, _) {
    return !_JSBI.equal(i, _);
  }
  static bitwiseAnd(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign) return _JSBI.__absoluteAnd(i, _).__trim();
    if (i.sign && _.sign) {
      const e = t(i.length, _.length) + 1;
      let n = _JSBI.__absoluteSubOne(i, e);
      const g = _JSBI.__absoluteSubOne(_);
      return n = _JSBI.__absoluteOr(n, g, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    return i.sign && ([i, _] = [_, i]), _JSBI.__absoluteAndNot(i, _JSBI.__absoluteSubOne(_)).__trim();
  }
  static bitwiseXor(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign) return _JSBI.__absoluteXor(i, _).__trim();
    if (i.sign && _.sign) {
      const e2 = t(i.length, _.length), n2 = _JSBI.__absoluteSubOne(i, e2), g = _JSBI.__absoluteSubOne(_);
      return _JSBI.__absoluteXor(n2, g, n2).__trim();
    }
    const e = t(i.length, _.length) + 1;
    i.sign && ([i, _] = [_, i]);
    let n = _JSBI.__absoluteSubOne(_, e);
    return n = _JSBI.__absoluteXor(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static bitwiseOr(i, _) {
    var t = Math.max;
    const e = t(i.length, _.length);
    if (!i.sign && !_.sign) return _JSBI.__absoluteOr(i, _).__trim();
    if (i.sign && _.sign) {
      let t2 = _JSBI.__absoluteSubOne(i, e);
      const n2 = _JSBI.__absoluteSubOne(_);
      return t2 = _JSBI.__absoluteAnd(t2, n2, t2), _JSBI.__absoluteAddOne(t2, true, t2).__trim();
    }
    i.sign && ([i, _] = [_, i]);
    let n = _JSBI.__absoluteSubOne(_, e);
    return n = _JSBI.__absoluteAndNot(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static asIntN(_, t) {
    var i = Math.floor;
    if (0 === t.length) return t;
    if (_ = i(_), 0 > _) throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === _) return _JSBI.__zero();
    if (_ >= _JSBI.__kMaxLengthBits) return t;
    const e = 0 | (_ + 29) / 30;
    if (t.length < e) return t;
    const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
    if (t.length === e && g < o) return t;
    if (!((g & o) === o)) return _JSBI.__truncateToNBits(_, t);
    if (!t.sign) return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, true);
    if (0 == (g & o - 1)) {
      for (let n = e - 2; 0 <= n; n--) if (0 !== t.__digit(n)) return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
      return t.length === e && g === o ? t : _JSBI.__truncateToNBits(_, t);
    }
    return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
  }
  static asUintN(i, _) {
    var t = Math.floor;
    if (0 === _.length) return _;
    if (i = t(i), 0 > i) throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === i) return _JSBI.__zero();
    if (_.sign) {
      if (i > _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
      return _JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
    }
    if (i >= _JSBI.__kMaxLengthBits) return _;
    const e = 0 | (i + 29) / 30;
    if (_.length < e) return _;
    const g = i % 30;
    if (_.length == e) {
      if (0 === g) return _;
      const i2 = _.__digit(e - 1);
      if (0 == i2 >>> g) return _;
    }
    return _JSBI.__truncateToNBits(i, _);
  }
  static ADD(i, _) {
    if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i) return "string" != typeof _ && (_ = _.toString()), i + _;
    if ("string" == typeof _) return i.toString() + _;
    if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i) && _JSBI.__isBigInt(_)) return _JSBI.add(i, _);
    if ("number" == typeof i && "number" == typeof _) return i + _;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i, _) {
    return _JSBI.__compare(i, _, 0);
  }
  static LE(i, _) {
    return _JSBI.__compare(i, _, 1);
  }
  static GT(i, _) {
    return _JSBI.__compare(i, _, 2);
  }
  static GE(i, _) {
    return _JSBI.__compare(i, _, 3);
  }
  static EQ(i, _) {
    for (; ; ) {
      if (_JSBI.__isBigInt(i)) return _JSBI.__isBigInt(_) ? _JSBI.equal(i, _) : _JSBI.EQ(_, i);
      if ("number" == typeof i) {
        if (_JSBI.__isBigInt(_)) return _JSBI.__equalToNumber(_, i);
        if ("object" != typeof _) return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("string" == typeof i) {
        if (_JSBI.__isBigInt(_)) return i = _JSBI.__fromString(i), null !== i && _JSBI.equal(i, _);
        if ("object" != typeof _) return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("boolean" == typeof i) {
        if (_JSBI.__isBigInt(_)) return _JSBI.__equalToNumber(_, +i);
        if ("object" != typeof _) return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("symbol" == typeof i) {
        if (_JSBI.__isBigInt(_)) return false;
        if ("object" != typeof _) return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("object" == typeof i) {
        if ("object" == typeof _ && _.constructor !== _JSBI) return i == _;
        i = _JSBI.__toPrimitive(i);
      } else return i == _;
    }
  }
  static NE(i, _) {
    return !_JSBI.EQ(i, _);
  }
  static __zero() {
    return new _JSBI(0, false);
  }
  static __oneDigit(i, _) {
    const t = new _JSBI(1, _);
    return t.__setDigit(0, i), t;
  }
  __copy() {
    const _ = new _JSBI(this.length, this.sign);
    for (let t = 0; t < this.length; t++) _[t] = this[t];
    return _;
  }
  __trim() {
    let i = this.length, _ = this[i - 1];
    for (; 0 === _; ) i--, _ = this[i - 1], this.pop();
    return 0 === i && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _ = 0; _ < this.length; _++) this[_] = 0;
  }
  static __decideRounding(i, _, t, e) {
    if (0 < _) return -1;
    let n;
    if (0 > _) n = -_ - 1;
    else {
      if (0 === t) return -1;
      t--, e = i.__digit(t), n = 29;
    }
    let g = 1 << n;
    if (0 == (e & g)) return -1;
    if (g -= 1, 0 != (e & g)) return 1;
    for (; 0 < t; ) if (t--, 0 !== i.__digit(t)) return 1;
    return 0;
  }
  static __fromDouble(i) {
    _JSBI.__kBitConversionDouble[0] = i;
    const _ = 2047 & _JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new _JSBI(e, 0 > i);
    let g = 1048575 & _JSBI.__kBitConversionInts[1] | 1048576, o = _JSBI.__kBitConversionInts[0];
    const s = 20, l = t % 30;
    let r, a = 0;
    if (l < 20) {
      const i2 = s - l;
      a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
    } else if (l === 20) a = 32, r = g, g = o, o = 0;
    else {
      const i2 = l - s;
      a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
    }
    n.__setDigit(e - 1, r);
    for (let _2 = e - 2; 0 <= _2; _2--) 0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
    return n.__trim();
  }
  static __isWhitespace(i) {
    return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
  }
  static __fromString(i, _ = 0) {
    let t = 0;
    const e = i.length;
    let n = 0;
    if (n === e) return _JSBI.__zero();
    let g = i.charCodeAt(n);
    for (; _JSBI.__isWhitespace(g); ) {
      if (++n === e) return _JSBI.__zero();
      g = i.charCodeAt(n);
    }
    if (43 === g) {
      if (++n === e) return null;
      g = i.charCodeAt(n), t = 1;
    } else if (45 === g) {
      if (++n === e) return null;
      g = i.charCodeAt(n), t = -1;
    }
    if (0 === _) {
      if (_ = 10, 48 === g) {
        if (++n === e) return _JSBI.__zero();
        if (g = i.charCodeAt(n), 88 === g || 120 === g) {
          if (_ = 16, ++n === e) return null;
          g = i.charCodeAt(n);
        } else if (79 === g || 111 === g) {
          if (_ = 8, ++n === e) return null;
          g = i.charCodeAt(n);
        } else if (66 === g || 98 === g) {
          if (_ = 2, ++n === e) return null;
          g = i.charCodeAt(n);
        }
      }
    } else if (16 === _ && 48 === g) {
      if (++n === e) return _JSBI.__zero();
      if (g = i.charCodeAt(n), 88 === g || 120 === g) {
        if (++n === e) return null;
        g = i.charCodeAt(n);
      }
    }
    if (0 != t && 10 !== _) return null;
    for (; 48 === g; ) {
      if (++n === e) return _JSBI.__zero();
      g = i.charCodeAt(n);
    }
    const o = e - n;
    let s = _JSBI.__kMaxBitsPerChar[_], l = _JSBI.__kBitsPerCharTableMultiplier - 1;
    if (o > 1073741824 / s) return null;
    const r = s * o + l >>> _JSBI.__kBitsPerCharTableShift, a = new _JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
    if (0 == (_ & _ - 1)) {
      s >>= _JSBI.__kBitsPerCharTableShift;
      const _2 = [], t2 = [];
      let o2 = false;
      do {
        let l2 = 0, r2 = 0;
        for (; ; ) {
          let _3;
          if (g - 48 >>> 0 < u) _3 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h) _3 = (32 | g) - 87;
          else {
            o2 = true;
            break;
          }
          if (r2 += s, l2 = l2 << s | _3, ++n === e) {
            o2 = true;
            break;
          }
          if (g = i.charCodeAt(n), 30 < r2 + s) break;
        }
        _2.push(l2), t2.push(r2);
      } while (!o2);
      _JSBI.__fillFromParts(a, _2, t2);
    } else {
      a.__initializeDigits();
      let t2 = false, o2 = 0;
      do {
        let r2 = 0, b = 1;
        for (; ; ) {
          let s2;
          if (g - 48 >>> 0 < u) s2 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h) s2 = (32 | g) - 87;
          else {
            t2 = true;
            break;
          }
          const l2 = b * _;
          if (1073741823 < l2) break;
          if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
            t2 = true;
            break;
          }
          g = i.charCodeAt(n);
        }
        l = 30 * _JSBI.__kBitsPerCharTableMultiplier - 1;
        const D = 0 | (s * o2 + l >>> _JSBI.__kBitsPerCharTableShift) / 30;
        a.__inplaceMultiplyAdd(b, r2, D);
      } while (!t2);
    }
    if (n !== e) {
      if (!_JSBI.__isWhitespace(g)) return null;
      for (n++; n < e; n++) if (g = i.charCodeAt(n), !_JSBI.__isWhitespace(g)) return null;
    }
    return a.sign = -1 == t, a.__trim();
  }
  static __fillFromParts(_, t, e) {
    let n = 0, g = 0, o = 0;
    for (let s = t.length - 1; 0 <= s; s--) {
      const i = t[s], l = e[s];
      g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
    }
    if (0 !== g) {
      if (n >= _.length) throw new Error("implementation bug");
      _.__setDigit(n++, g);
    }
    for (; n < _.length; n++) _.__setDigit(n, 0);
  }
  static __toStringBasePowerOfTwo(_, i) {
    const t = _.length;
    let e = i - 1;
    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
    const n = e, g = i - 1, o = _.__digit(t - 1), s = _JSBI.__clz30(o);
    let l = 0 | (30 * t - s + n - 1) / n;
    if (_.sign && l++, 268435456 < l) throw new Error("string too long");
    const r = Array(l);
    let a = l - 1, u = 0, d = 0;
    for (let e2 = 0; e2 < t - 1; e2++) {
      const i2 = _.__digit(e2), t2 = (u | i2 << d) & g;
      r[a--] = _JSBI.__kConversionChars[t2];
      const o2 = n - d;
      for (u = i2 >>> o2, d = 30 - o2; d >= n; ) r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
    }
    const h = (u | o << d) & g;
    for (r[a--] = _JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u; ) r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n;
    if (_.sign && (r[a--] = "-"), -1 != a) throw new Error("implementation bug");
    return r.join("");
  }
  static __toStringGeneric(_, i, t) {
    const e = _.length;
    if (0 === e) return "";
    if (1 === e) {
      let e2 = _.__unsignedDigit(0).toString(i);
      return false === t && _.sign && (e2 = "-" + e2), e2;
    }
    const n = 30 * e - _JSBI.__clz30(_.__digit(e - 1)), g = _JSBI.__kMaxBitsPerChar[i], o = g - 1;
    let s = n * _JSBI.__kBitsPerCharTableMultiplier;
    s += o - 1, s = 0 | s / o;
    const l = s + 1 >> 1, r = _JSBI.exponentiate(_JSBI.__oneDigit(i, false), _JSBI.__oneDigit(l, false));
    let a, u;
    const d = r.__unsignedDigit(0);
    if (1 === r.length && 32767 >= d) {
      a = new _JSBI(_.length, false), a.__initializeDigits();
      let t2 = 0;
      for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
        const i2 = t2 << 15 | _.__halfDigit(e2);
        a.__setHalfDigit(e2, 0 | i2 / d), t2 = 0 | i2 % d;
      }
      u = t2.toString(i);
    } else {
      const t2 = _JSBI.__absoluteDivLarge(_, r, true, true);
      a = t2.quotient;
      const e2 = t2.remainder.__trim();
      u = _JSBI.__toStringGeneric(e2, i, true);
    }
    a.__trim();
    let h = _JSBI.__toStringGeneric(a, i, true);
    for (; u.length < l; ) u = "0" + u;
    return false === t && _.sign && (h = "-" + h), h + u;
  }
  static __unequalSign(i) {
    return i ? -1 : 1;
  }
  static __absoluteGreater(i) {
    return i ? -1 : 1;
  }
  static __absoluteLess(i) {
    return i ? 1 : -1;
  }
  static __compareToBigInt(i, _) {
    const t = i.sign;
    if (t !== _.sign) return _JSBI.__unequalSign(t);
    const e = _JSBI.__absoluteCompare(i, _);
    return 0 < e ? _JSBI.__absoluteGreater(t) : 0 > e ? _JSBI.__absoluteLess(t) : 0;
  }
  static __compareToNumber(i, _) {
    if (_JSBI.__isOneDigitInt(_)) {
      const t = i.sign, e = 0 > _;
      if (t !== e) return _JSBI.__unequalSign(t);
      if (0 === i.length) {
        if (e) throw new Error("implementation bug");
        return 0 === _ ? 0 : -1;
      }
      if (1 < i.length) return _JSBI.__absoluteGreater(t);
      const n = Math.abs(_), g = i.__unsignedDigit(0);
      return g > n ? _JSBI.__absoluteGreater(t) : g < n ? _JSBI.__absoluteLess(t) : 0;
    }
    return _JSBI.__compareToDouble(i, _);
  }
  static __compareToDouble(i, _) {
    if (_ !== _) return _;
    if (_ === 1 / 0) return -1;
    if (_ === -Infinity) return 1;
    const t = i.sign;
    if (t !== 0 > _) return _JSBI.__unequalSign(t);
    if (0 === _) throw new Error("implementation bug: should be handled elsewhere");
    if (0 === i.length) return -1;
    _JSBI.__kBitConversionDouble[0] = _;
    const e = 2047 & _JSBI.__kBitConversionInts[1] >>> 20;
    if (2047 == e) throw new Error("implementation bug: handled elsewhere");
    const n = e - 1023;
    if (0 > n) return _JSBI.__absoluteGreater(t);
    const g = i.length;
    let o = i.__digit(g - 1);
    const s = _JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
    if (l < r) return _JSBI.__absoluteLess(t);
    if (l > r) return _JSBI.__absoluteGreater(t);
    let a = 1048576 | 1048575 & _JSBI.__kBitConversionInts[1], u = _JSBI.__kBitConversionInts[0];
    const d = 20, h = 29 - s;
    if (h !== (0 | (l - 1) % 30)) throw new Error("implementation bug");
    let m, b = 0;
    if (20 > h) {
      const i2 = d - h;
      b = i2 + 32, m = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
    } else if (20 === h) b = 32, m = a, a = u, u = 0;
    else {
      const i2 = h - d;
      b = 32 - i2, m = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
    }
    if (o >>>= 0, m >>>= 0, o > m) return _JSBI.__absoluteGreater(t);
    if (o < m) return _JSBI.__absoluteLess(t);
    for (let e2 = g - 2; 0 <= e2; e2--) {
      0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
      const _2 = i.__unsignedDigit(e2);
      if (_2 > m) return _JSBI.__absoluteGreater(t);
      if (_2 < m) return _JSBI.__absoluteLess(t);
    }
    if (0 !== a || 0 !== u) {
      if (0 === b) throw new Error("implementation bug");
      return _JSBI.__absoluteLess(t);
    }
    return 0;
  }
  static __equalToNumber(i, _) {
    var t = Math.abs;
    return _JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === _JSBI.__compareToDouble(i, _);
  }
  static __comparisonResultToBool(i, _) {
    return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
  }
  static __compare(i, _, t) {
    if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _) switch (t) {
      case 0:
        return i < _;
      case 1:
        return i <= _;
      case 2:
        return i > _;
      case 3:
        return i >= _;
    }
    if (_JSBI.__isBigInt(i) && "string" == typeof _) return _ = _JSBI.__fromString(_), null !== _ && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
    if ("string" == typeof i && _JSBI.__isBigInt(_)) return i = _JSBI.__fromString(i), null !== i && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
    if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i)) {
      if (_JSBI.__isBigInt(_)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
      if ("number" != typeof _) throw new Error("implementation bug");
      return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(i, _), t);
    }
    if ("number" != typeof i) throw new Error("implementation bug");
    if (_JSBI.__isBigInt(_)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(_, i), 2 ^ t);
    if ("number" != typeof _) throw new Error("implementation bug");
    return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;
  }
  __clzmsd() {
    return _JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_, t, e) {
    if (_.length < t.length) return _JSBI.__absoluteAdd(t, _, e);
    if (0 === _.length) return _;
    if (0 === t.length) return _.sign === e ? _ : _JSBI.unaryMinus(_);
    let n = _.length;
    (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;
    const g = new _JSBI(n, e);
    let o = 0, s = 0;
    for (; s < t.length; s++) {
      const i = _.__digit(s) + t.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    for (; s < _.length; s++) {
      const i = _.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    return s < g.length && g.__setDigit(s, o), g.__trim();
  }
  static __absoluteSub(_, t, e) {
    if (0 === _.length) return _;
    if (0 === t.length) return _.sign === e ? _ : _JSBI.unaryMinus(_);
    const n = new _JSBI(_.length, e);
    let g = 0, o = 0;
    for (; o < t.length; o++) {
      const i = _.__digit(o) - t.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    for (; o < _.length; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    return n.__trim();
  }
  static __absoluteAddOne(_, i, t = null) {
    const e = _.length;
    null === t ? t = new _JSBI(e, i) : t.sign = i;
    let n = 1;
    for (let g = 0; g < e; g++) {
      const i2 = _.__digit(g) + n;
      n = i2 >>> 30, t.__setDigit(g, 1073741823 & i2);
    }
    return 0 != n && t.__setDigitGrow(e, 1), t;
  }
  static __absoluteSubOne(_, t) {
    const e = _.length;
    t = t || e;
    const n = new _JSBI(t, false);
    let g = 1;
    for (let o = 0; o < e; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    if (0 != g) throw new Error("implementation bug");
    for (let g2 = e; g2 < t; g2++) n.__setDigit(g2, 0);
    return n;
  }
  static __absoluteAnd(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = o;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++) e.__setDigit(l, _.__digit(l) & t.__digit(l));
    for (; l < s; l++) e.__setDigit(l, 0);
    return e;
  }
  static __absoluteAndNot(_, t, e = null) {
    const n = _.length, g = t.length;
    let o = g;
    n < g && (o = n);
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++) e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
    for (; l < n; l++) e.__setDigit(l, _.__digit(l));
    for (; l < s; l++) e.__setDigit(l, 0);
    return e;
  }
  static __absoluteOr(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++) e.__setDigit(l, _.__digit(l) | t.__digit(l));
    for (; l < n; l++) e.__setDigit(l, _.__digit(l));
    for (; l < s; l++) e.__setDigit(l, 0);
    return e;
  }
  static __absoluteXor(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++) e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
    for (; l < n; l++) e.__setDigit(l, _.__digit(l));
    for (; l < s; l++) e.__setDigit(l, 0);
    return e;
  }
  static __absoluteCompare(_, t) {
    const e = _.length - t.length;
    if (0 != e) return e;
    let n = _.length - 1;
    for (; 0 <= n && _.__digit(n) === t.__digit(n); ) n--;
    return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
  }
  static __multiplyAccumulate(_, t, e, n) {
    if (0 === t) return;
    const g = 32767 & t, o = t >>> 15;
    let s = 0, l = 0;
    for (let r, a = 0; a < _.length; a++, n++) {
      r = e.__digit(n);
      const i = _.__digit(a), t2 = 32767 & i, u = i >>> 15, d = _JSBI.__imul(t2, g), h = _JSBI.__imul(t2, o), m = _JSBI.__imul(u, g), b = _JSBI.__imul(u, o);
      r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
    }
    for (; 0 != s || 0 !== l; n++) {
      let i = e.__digit(n);
      i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
    }
  }
  static __internalMultiplyAdd(_, t, e, g, o) {
    let s = e, l = 0;
    for (let n = 0; n < g; n++) {
      const i = _.__digit(n), e2 = _JSBI.__imul(32767 & i, t), g2 = _JSBI.__imul(i >>> 15, t), a = e2 + ((32767 & g2) << 15) + l + s;
      s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
    }
    if (o.length > g) for (o.__setDigit(g++, s + l); g < o.length; ) o.__setDigit(g++, 0);
    else if (0 !== s + l) throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i, _, t) {
    t > this.length && (t = this.length);
    const e = 32767 & i, n = i >>> 15;
    let g = 0, o = _;
    for (let s = 0; s < t; s++) {
      const i2 = this.__digit(s), _2 = 32767 & i2, t2 = i2 >>> 15, l = _JSBI.__imul(_2, e), r = _JSBI.__imul(_2, n), a = _JSBI.__imul(t2, e), u = _JSBI.__imul(t2, n);
      let d = o + l + g;
      g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
    }
    if (0 != g || 0 !== o) throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_, t, e = null) {
    null === e && (e = new _JSBI(_.length, false));
    let n = 0;
    for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
      g = (n << 15 | _.__halfDigit(o)) >>> 0;
      const i = 0 | g / t;
      n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
      const s = 0 | g / t;
      n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
    }
    return e;
  }
  static __absoluteModSmall(_, t) {
    let e = 0;
    for (let n = 2 * _.length - 1; 0 <= n; n--) {
      const i = (e << 15 | _.__halfDigit(n)) >>> 0;
      e = 0 | i % t;
    }
    return e;
  }
  static __absoluteDivLarge(i, _, t, e) {
    const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
    let s = null;
    t && (s = new _JSBI(o + 2 >>> 1, false), s.__initializeDigits());
    const l = new _JSBI(g + 2 >>> 1, false);
    l.__initializeDigits();
    const r = _JSBI.__clz15(_.__halfDigit(g - 1));
    0 < r && (_ = _JSBI.__specialLeftShift(_, r, 0));
    const a = _JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
    let d = 0;
    for (let r2, h = o; 0 <= h; h--) {
      r2 = 32767;
      const i2 = a.__halfDigit(h + g);
      if (i2 !== u) {
        const t2 = (i2 << 15 | a.__halfDigit(h + g - 1)) >>> 0;
        r2 = 0 | t2 / u;
        let e3 = 0 | t2 % u;
        const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h + g - 2);
        for (; _JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); ) ;
      }
      _JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
      let e2 = a.__inplaceSub(l, h, g + 1);
      0 !== e2 && (e2 = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e2), r2--), t && (1 & h ? d = r2 << 15 : s.__setDigit(h >>> 1, d | r2));
    }
    if (e) return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a;
    if (t) return s;
    throw new Error("unreachable");
  }
  static __clz15(i) {
    return _JSBI.__clz30(i) - 15;
  }
  __inplaceAdd(_, t, e) {
    let n = 0;
    for (let g = 0; g < e; g++) {
      const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
      n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
    }
    return n;
  }
  __inplaceSub(_, t, e) {
    let n = 0;
    if (1 & t) {
      t >>= 1;
      let g = this.__digit(t), o = 32767 & g, s = 0;
      for (; s < e - 1 >>> 1; s++) {
        const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
        n = 1 & e2 >>> 15, this.__setDigit(t + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
      }
      const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
      n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
      if (t + s + 1 >= this.length) throw new RangeError("out of bounds");
      0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
    } else {
      t >>= 1;
      let g = 0;
      for (; g < _.length - 1; g++) {
        const i2 = this.__digit(t + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
        n = 1 & o2 >>> 15;
        const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
        n = 1 & s2 >>> 15, this.__setDigit(t + g, (32767 & s2) << 15 | 32767 & o2);
      }
      const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
      n = 1 & s >>> 15;
      let l = 0;
      0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
    }
    return n;
  }
  __inplaceRightShift(_) {
    if (0 === _) return;
    let t = this.__digit(0) >>> _;
    const e = this.length - 1;
    for (let n = 0; n < e; n++) {
      const i = this.__digit(n + 1);
      this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
    }
    this.__setDigit(e, t);
  }
  static __specialLeftShift(_, t, e) {
    const g = _.length, n = new _JSBI(g + e, false);
    if (0 === t) {
      for (let t2 = 0; t2 < g; t2++) n.__setDigit(t2, _.__digit(t2));
      return 0 < e && n.__setDigit(g, 0), n;
    }
    let o = 0;
    for (let s = 0; s < g; s++) {
      const i = _.__digit(s);
      n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
    }
    return 0 < e && n.__setDigit(g, o), n;
  }
  static __leftShiftByAbsolute(_, i) {
    const t = _JSBI.__toShiftAmount(i);
    if (0 > t) throw new RangeError("BigInt too big");
    const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new _JSBI(s, _.sign);
    if (0 === n) {
      let t2 = 0;
      for (; t2 < e; t2++) l.__setDigit(t2, 0);
      for (; t2 < s; t2++) l.__setDigit(t2, _.__digit(t2 - e));
    } else {
      let t2 = 0;
      for (let _2 = 0; _2 < e; _2++) l.__setDigit(_2, 0);
      for (let o2 = 0; o2 < g; o2++) {
        const i2 = _.__digit(o2);
        l.__setDigit(o2 + e, 1073741823 & i2 << n | t2), t2 = i2 >>> 30 - n;
      }
      if (o) l.__setDigit(g + e, t2);
      else if (0 !== t2) throw new Error("implementation bug");
    }
    return l.__trim();
  }
  static __rightShiftByAbsolute(_, i) {
    const t = _.length, e = _.sign, n = _JSBI.__toShiftAmount(i);
    if (0 > n) return _JSBI.__rightShiftByMaximum(e);
    const g = 0 | n / 30, o = n % 30;
    let s = t - g;
    if (0 >= s) return _JSBI.__rightShiftByMaximum(e);
    let l = false;
    if (e) {
      if (0 != (_.__digit(g) & (1 << o) - 1)) l = true;
      else for (let t2 = 0; t2 < g; t2++) if (0 !== _.__digit(t2)) {
        l = true;
        break;
      }
    }
    if (l && 0 === o) {
      const i2 = _.__digit(t - 1);
      0 == ~i2 && s++;
    }
    let r = new _JSBI(s, e);
    if (0 === o) {
      r.__setDigit(s - 1, 0);
      for (let e2 = g; e2 < t; e2++) r.__setDigit(e2 - g, _.__digit(e2));
    } else {
      let e2 = _.__digit(g) >>> o;
      const n2 = t - g - 1;
      for (let t2 = 0; t2 < n2; t2++) {
        const i2 = _.__digit(t2 + g + 1);
        r.__setDigit(t2, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
      }
      r.__setDigit(n2, e2);
    }
    return l && (r = _JSBI.__absoluteAddOne(r, true, r)), r.__trim();
  }
  static __rightShiftByMaximum(i) {
    return i ? _JSBI.__oneDigit(1, true) : _JSBI.__zero();
  }
  static __toShiftAmount(i) {
    if (1 < i.length) return -1;
    const _ = i.__unsignedDigit(0);
    return _ > _JSBI.__kMaxLengthBits ? -1 : _;
  }
  static __toPrimitive(i, _ = "default") {
    if ("object" != typeof i) return i;
    if (i.constructor === _JSBI) return i;
    if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
      const t2 = i[Symbol.toPrimitive];
      if (t2) {
        const i2 = t2(_);
        if ("object" != typeof i2) return i2;
        throw new TypeError("Cannot convert object to primitive value");
      }
    }
    const t = i.valueOf;
    if (t) {
      const _2 = t.call(i);
      if ("object" != typeof _2) return _2;
    }
    const e = i.toString;
    if (e) {
      const _2 = e.call(i);
      if ("object" != typeof _2) return _2;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i) {
    return _JSBI.__isBigInt(i) ? i : +i;
  }
  static __isBigInt(i) {
    return "object" == typeof i && null !== i && i.constructor === _JSBI;
  }
  static __truncateToNBits(i, _) {
    const t = 0 | (i + 29) / 30, e = new _JSBI(t, _.sign), n = t - 1;
    for (let t2 = 0; t2 < n; t2++) e.__setDigit(t2, _.__digit(t2));
    let g = _.__digit(n);
    if (0 != i % 30) {
      const _2 = 32 - i % 30;
      g = g << _2 >>> _2;
    }
    return e.__setDigit(n, g), e.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_, t, e) {
    var n = Math.min;
    const g = 0 | (_ + 29) / 30, o = new _JSBI(g, e);
    let s = 0;
    const l = g - 1;
    let a = 0;
    for (const i = n(l, t.length); s < i; s++) {
      const i2 = 0 - t.__digit(s) - a;
      a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
    }
    for (; s < l; s++) o.__setDigit(s, 0 | 1073741823 & -a);
    let u = l < t.length ? t.__digit(l) : 0;
    const d = _ % 30;
    let h;
    if (0 == d) h = 0 - u - a, h &= 1073741823;
    else {
      const i = 32 - d;
      u = u << i >>> i;
      const _2 = 1 << 32 - i;
      h = _2 - u - a, h &= _2 - 1;
    }
    return o.__setDigit(l, h), o.__trim();
  }
  __digit(_) {
    return this[_];
  }
  __unsignedDigit(_) {
    return this[_] >>> 0;
  }
  __setDigit(_, i) {
    this[_] = 0 | i;
  }
  __setDigitGrow(_, i) {
    this[_] = 0 | i;
  }
  __halfDigitLength() {
    const i = this.length;
    return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
  }
  __halfDigit(_) {
    return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
  }
  __setHalfDigit(_, i) {
    const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
    this.__setDigit(t, n);
  }
  static __digitPow(i, _) {
    let t = 1;
    for (; 0 < _; ) 1 & _ && (t *= i), _ >>>= 1, i *= i;
    return t;
  }
  static __isOneDigitInt(i) {
    return (1073741823 & i) === i;
  }
};
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
  return Math.clz32(i) - 2;
} : function(i) {
  return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i, _) {
  return 0 | i * _;
};
var jsbi_default = JSBI;

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/decimal.js-light/decimal.mjs
var MAX_DIGITS = 1e9;
var defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
};
var Decimal;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var exponentOutOfRange = decimalError + "Exponent out of range: ";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var ONE;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE);
var P = {};
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s) x.s = 1;
  return x;
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this;
  y = new x.constructor(y);
  if (x.s !== y.s) return x.s || -y.s;
  if (x.e !== y.e) return x.e > y.e ^ x.s < 0 ? 1 : -1;
  xdL = x.d.length;
  ydL = y.d.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x.d[i] !== y.d[i]) return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE;
  w = x.d[w];
  if (w) for (; w % 10 == 0; w /= 10) dp--;
  return dp < 0 ? 0 : dp;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.idiv = function(y) {
  var x = this, Ctor = x.constructor;
  return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
};
P.equals = P.eq = function(y) {
  return !this.cmp(y);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  return this.cmp(y) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var r, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
  }
  if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE)) return new Ctor(0);
  external = false;
  r = divide(ln(x, wpr), ln(base, wpr), wpr);
  external = true;
  return round(r, pr);
};
P.minus = P.sub = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
  y = new Ctor(y);
  if (!y.s) throw Error(decimalError + "NaN");
  if (!x.s) return round(new Ctor(x), pr);
  external = false;
  q = divide(x, y, 0, 1).times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s || 0;
  return x;
};
P.plus = P.add = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
};
P.precision = P.sd = function(z) {
  var e, sd, w, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  e = getBase10Exponent(x) + 1;
  w = x.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x.d[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) sd--;
    for (w = x.d[0]; w >= 10; w /= 10) sd++;
  }
  return z && e > sd ? e : sd;
};
P.squareRoot = P.sqrt = function() {
  var e, n, pr, r, s, t, wpr, x = this, Ctor = x.constructor;
  if (x.s < 1) {
    if (!x.s) return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e = getBase10Exponent(x);
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(x.d);
    if ((n.length + e) % 2 == 0) n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  pr = Ctor.precision;
  s = wpr = pr + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, wpr + 2)).times(0.5);
    if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
      n = n.slice(wpr - 3, wpr + 1);
      if (s == wpr && n == "4999") {
        round(t, pr + 1, 0);
        if (t.times(t).eq(x)) {
          r = t;
          break;
        }
      } else if (n != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round(r, pr);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  if (!x.s || !y.s) return new Ctor(0);
  y.s *= x.s;
  e = x.e + y.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y.d = r;
  y.e = e;
  return external ? round(y, Ctor.precision) : y;
};
P.toDecimalPlaces = P.todp = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0) return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return round(x, dp + getBase10Exponent(x) + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = toString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = round(new Ctor(x), dp + 1, rm);
    str = toString(x, true, dp + 1);
  }
  return str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) return toString(x);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
  str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);
  return x.isneg() && !x.isZero() ? "-" + str : str;
};
P.toInteger = P.toint = function() {
  var x = this, Ctor = x.constructor;
  return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
  if (!y.s) return new Ctor(ONE);
  x = new Ctor(x);
  if (!x.s) {
    if (y.s < 1) throw Error(decimalError + "Infinity");
    return x;
  }
  if (x.eq(ONE)) return x;
  pr = Ctor.precision;
  if (y.eq(ONE)) return round(x, pr);
  e = y.e;
  k = y.d.length - 1;
  yIsInt = e >= k;
  sign = x.s;
  if (!yIsInt) {
    if (sign < 0) throw Error(decimalError + "NaN");
  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = new Ctor(ONE);
    e = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k % 2) {
        r = r.times(x);
        truncate(r.d, e);
      }
      k = mathfloor(k / 2);
      if (k === 0) break;
      x = x.times(x);
      truncate(x.d, e);
    }
    external = true;
    return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
  }
  sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
  x.s = 1;
  external = false;
  r = y.times(ln(x, pr + guard));
  external = true;
  r = exp(r);
  r.s = sign;
  return r;
};
P.toPrecision = function(sd, rm) {
  var e, str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    e = getBase10Exponent(x);
    str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = round(new Ctor(x), sd, rm);
    e = getBase10Exponent(x);
    str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
  }
  return str;
};
P.toSignificantDigits = P.tosd = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return round(new Ctor(x), sd, rm);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
  return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};
function add(x, y) {
  var carry, d, e, i, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (!y.s) y = new Ctor(x);
    return external ? round(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  k = x.e;
  e = y.e;
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = e;
  return external ? round(y, pr) : y;
}
function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry) x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * BASE + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; ) a.shift();
  }
  return function(x, y, pr, dp) {
    var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!x.s) return new Ctor(x);
    if (!y.s) throw Error(decimalError + "Division by zero");
    e = x.e - y.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); ) ++i;
    if (yd[i] > (xd[i] || 0)) --e;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k = 0;
      yd = yd[0];
      sd++;
      for (; (i < xL || k) && sd--; i++) {
        t = k * BASE + (xd[i] || 0);
        qd[i] = t / yd | 0;
        k = t % yd | 0;
      }
    } else {
      k = BASE / (yd[0] + 1) | 0;
      if (k > 1) {
        yd = multiplyInteger(yd, k);
        xd = multiplyInteger(xd, k);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; ) rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2) ++yd0;
      do {
        k = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
          k = rem0 / yd0 | 0;
          if (k > 1) {
            if (k >= BASE) k = BASE - 1;
            prod = multiplyInteger(yd, k);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k == 0) cmp = k = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL) prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k++;
          rem = [0];
        }
        qd[i++] = k;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0]) qd.shift();
    q.e = e;
    return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
}();
function exp(x, sd) {
  var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x));
  if (!x.s) return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.abs().gte(0.1)) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow = round(pow.times(x), wpr);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k--) sum = round(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t;
  }
}
function getBase10Exponent(x) {
  var e = x.e * LOG_BASE, w = x.d[0];
  for (; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function ln(y, sd) {
  var c, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
  if (x.s < 1) throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE)) return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x.eq(10)) {
    if (sd == null) external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  e = getBase10Exponent(x);
  if (Math.abs(e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = getBase10Exponent(x);
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? (external = true, round(x, pr)) : x;
  }
  sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
  x2 = round(x.times(x), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round(numerator.times(x2), wpr);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum, pr)) : sum;
    }
    sum = t;
    denominator += 2;
  }
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; ) ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; ) --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e = e - i - 1;
    x.e = mathfloor(e / LOG_BASE);
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x.d.push(+str);
    if (external && (x.e > MAX_E || x.e < -MAX_E)) throw Error(exponentOutOfRange + e);
  } else {
    x.s = 0;
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function round(x, sd, rm) {
  var i, j, k, n, rd, doRound, w, xdi, xd = x.d;
  for (n = 1, k = xd[0]; k >= 10; k /= 10) n++;
  i = sd - n;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k = xd.length;
    if (xdi >= k) return x;
    w = k = xd[xdi];
    for (n = 1; k >= 10; k /= 10) n++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n;
  }
  if (rm !== void 0) {
    k = mathpow(10, n - j - 1);
    rd = w / k % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k = getBase10Exponent(x);
      xd.length = 1;
      sd = sd - k - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x.e = x.s = 0;
    }
    return x;
  }
  if (i == 0) {
    xd.length = xdi;
    k = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k) == BASE) {
          xd[0] = 1;
          ++x.e;
        }
        break;
      } else {
        xd[xdi] += k;
        if (xd[xdi] != BASE) break;
        xd[xdi--] = 0;
        k = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; ) xd.pop();
  if (external && (x.e > MAX_E || x.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  }
  return x;
}
function subtract(x, y) {
  var d, e, i, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (y.s) y.s = -y.s;
    else y = new Ctor(x);
    return external ? round(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  e = y.e;
  xe = x.e;
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(0);
  y.d = xd;
  y.e = e;
  return external ? round(y, pr) : y;
}
function toString(x, isExp, sd) {
  var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k);
    }
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(value) {
    var x = this;
    if (!(x instanceof Decimal3)) return new Decimal3(value);
    x.constructor = Decimal3;
    if (value instanceof Decimal3) {
      x.s = value.s;
      x.e = value.e;
      x.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x.s = 1;
      } else if (value < 0) {
        value = -value;
        x.s = -1;
      } else {
        x.s = 0;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x.e = 0;
        x.d = [value];
        return;
      }
      return parseDecimal(x, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }
    if (isDecimal.test(value)) parseDecimal(x, value);
    else throw Error(invalidArgument + value);
  }
  Decimal3.prototype = P;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.clone = clone;
  Decimal3.config = Decimal3.set = config;
  if (obj === void 0) obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }
  Decimal3.config(obj);
  return Decimal3;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if ((v = obj[p = "LN10"]) !== void 0) {
    if (v == Math.LN10) this[p] = new this(v);
    else throw Error(invalidArgument + p + ": " + v);
  }
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
var decimal_default = Decimal;

// node_modules/big.js/big.mjs
var DP = 20;
var RM = 1;
var MAX_DP = 1e6;
var MAX_POWER = 1e6;
var NE = -7;
var PE = 21;
var NAME = "[big.js] ";
var INVALID = NAME + "Invalid ";
var INVALID_DP = INVALID + "decimal places";
var INVALID_RM = INVALID + "rounding mode";
var DIV_BY_ZERO = NAME + "Division by zero";
var P2 = {};
var UNDEFINED = void 0;
var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big3(n) {
    var x = this;
    if (!(x instanceof Big3)) return n === UNDEFINED ? _Big_() : new Big3(n);
    if (n instanceof Big3) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }
    x.constructor = Big3;
  }
  Big3.prototype = P2;
  Big3.DP = DP;
  Big3.RM = RM;
  Big3.NE = NE;
  Big3.PE = PE;
  Big3.version = "5.2.2";
  return Big3;
}
function parse(x, n) {
  var e, i, nl;
  if (n === 0 && 1 / n < 0) n = "-0";
  else if (!NUMERIC.test(n += "")) throw Error(INVALID + "number");
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1) n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; ) ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; ) ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; ) x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round2(x, dp, rm, more) {
  var xc = x.c, i = x.e + dp + 1;
  if (i < xc.length) {
    if (rm === 1) {
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0) throw Error(INVALID_RM);
    }
    if (i < 1) {
      xc.length = 1;
      if (more) {
        x.e = -dp;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else {
      xc.length = i--;
      if (more) {
        for (; ++xc[i] > 9; ) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }
      for (i = xc.length; !xc[--i]; ) xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x;
}
function stringify(x, id, n, k) {
  var e, s, Big3 = x.constructor, z = !x.c[0];
  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
    }
    x = new Big3(x);
    n = k - x.e;
    if (x.c.length > ++k) round2(x, n, Big3.RM);
    if (id == 2) k = x.e + n + 1;
    for (; x.c.length < k; ) x.c.push(0);
  }
  e = x.e;
  s = x.c.join("");
  n = s.length;
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big3.NE || e >= Big3.PE)) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; ) s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n) for (e -= n; e--; ) s += "0";
    else if (e < n) s = s.slice(0, e) + "." + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && (!z || id == 4) ? "-" + s : s;
}
P2.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P2.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;
  if (i != j) return i;
  isneg = i < 0;
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = -1; ++i < j; ) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P2.div = function(y) {
  var x = this, Big3 = x.constructor, a = x.c, b = (y = new Big3(y)).c, k = x.s == y.s ? 1 : -1, dp = Big3.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) throw Error(INVALID_DP);
  if (!b[0]) throw Error(DIV_BY_ZERO);
  if (!a[0]) return new Big3(k * 0);
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = d < 0 ? 0 : d;
  bz.unshift(0);
  for (; rl++ < bl; ) r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; ) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; ) r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
  }
  if (qi > d) round2(q, dp, Big3.RM, r[0] !== UNDEFINED);
  return q;
};
P2.eq = function(y) {
  return !this.cmp(y);
};
P2.gt = function(y) {
  return this.cmp(y) > 0;
};
P2.gte = function(y) {
  return this.cmp(y) > -1;
};
P2.lt = function(y) {
  return this.cmp(y) < 0;
};
P2.lte = function(y) {
  return this.cmp(y) < 1;
};
P2.minus = P2.sub = function(y) {
  var i, j, t, xlty, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    return yc[0] ? (y.s = -b, y) : new Big3(xc[0] ? x : 0);
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--; ) t.push(0);
    t.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--; ) xc[i++] = 0;
  for (b = i; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i]; ) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; ) xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P2.mod = function(y) {
  var ygtx, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (!y.c[0]) throw Error(DIV_BY_ZERO);
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big3(x);
  a = Big3.DP;
  b = Big3.RM;
  Big3.DP = Big3.RM = 0;
  x = x.div(y);
  Big3.DP = a;
  Big3.RM = b;
  return this.minus(x.times(y));
};
P2.plus = P2.add = function(y) {
  var t, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (a != b) {
    y.s = -b;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0]) return yc[0] ? y : new Big3(xc[0] ? x : a * 0);
  xc = xc.slice();
  if (a = xe - ye) {
    if (a > 0) {
      ye = xe;
      t = yc;
    } else {
      a = -a;
      t = xc;
    }
    t.reverse();
    for (; a--; ) t.push(0);
    t.reverse();
  }
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  a = yc.length;
  for (b = 0; a; xc[a] %= 10) b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
  if (b) {
    xc.unshift(b);
    ++ye;
  }
  for (a = xc.length; xc[--a] === 0; ) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P2.pow = function(n) {
  var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) throw Error(INVALID + "exponent");
  if (isneg) n = -n;
  for (; ; ) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P2.round = function(dp, rm) {
  var Big3 = this.constructor;
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) throw Error(INVALID_DP);
  return round2(new Big3(this), dp, rm === UNDEFINED ? Big3.RM : rm);
};
P2.sqrt = function() {
  var r, c, t, x = this, Big3 = x.constructor, s = x.s, e = x.e, half = new Big3(0.5);
  if (!x.c[0]) return new Big3(x);
  if (s < 0) throw Error(NAME + "No square root");
  s = Math.sqrt(x + "");
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1)) c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big3((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big3(s);
  }
  e = r.e + (Big3.DP += 4);
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round2(r, Big3.DP -= 4, Big3.RM);
};
P2.times = P2.mul = function(y) {
  var c, x = this, Big3 = x.constructor, xc = x.c, yc = (y = new Big3(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0]) return new Big3(y.s * 0);
  y.e = i + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; ) c[j] = 0;
  for (i = b; i--; ) {
    b = 0;
    for (j = a + i; j > i; ) {
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = (c[j] + b) % 10;
  }
  if (b) ++y.e;
  else c.shift();
  for (i = c.length; !c[--i]; ) c.pop();
  y.c = c;
  return y;
};
P2.toExponential = function(dp) {
  return stringify(this, 1, dp, dp);
};
P2.toFixed = function(dp) {
  return stringify(this, 2, dp, this.e + dp);
};
P2.toPrecision = function(sd) {
  return stringify(this, 3, sd, sd - 1);
};
P2.toString = function() {
  return stringify(this);
};
P2.valueOf = P2.toJSON = function() {
  return stringify(this, 4);
};
var Big = _Big_();
var big_default = Big;

// node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js
var import_toformat = __toESM(require_toFormat());

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version = "strings/5.7.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger = new Logger(version);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

// node_modules/@uniswap/sdk-core/dist/sdk-core.esm.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["GOERLI"] = 5] = "GOERLI";
  ChainId2[ChainId2["SEPOLIA"] = 11155111] = "SEPOLIA";
  ChainId2[ChainId2["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId2[ChainId2["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
  ChainId2[ChainId2["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId2[ChainId2["ARBITRUM_SEPOLIA"] = 421614] = "ARBITRUM_SEPOLIA";
  ChainId2[ChainId2["POLYGON"] = 137] = "POLYGON";
  ChainId2[ChainId2["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId2[ChainId2["CELO"] = 42220] = "CELO";
  ChainId2[ChainId2["CELO_ALFAJORES"] = 44787] = "CELO_ALFAJORES";
  ChainId2[ChainId2["GNOSIS"] = 100] = "GNOSIS";
  ChainId2[ChainId2["MOONBEAM"] = 1284] = "MOONBEAM";
  ChainId2[ChainId2["BNB"] = 56] = "BNB";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
  ChainId2[ChainId2["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
  ChainId2[ChainId2["BASE"] = 8453] = "BASE";
  ChainId2[ChainId2["ZORA"] = 7777777] = "ZORA";
  ChainId2[ChainId2["ZORA_SEPOLIA"] = 999999999] = "ZORA_SEPOLIA";
  ChainId2[ChainId2["ROOTSTOCK"] = 30] = "ROOTSTOCK";
  ChainId2[ChainId2["BLAST"] = 81457] = "BLAST";
  ChainId2[ChainId2["ZKSYNC"] = 324] = "ZKSYNC";
  ChainId2[ChainId2["WORLDCHAIN"] = 480] = "WORLDCHAIN";
  ChainId2[ChainId2["UNICHAIN_SEPOLIA"] = 1301] = "UNICHAIN_SEPOLIA";
  ChainId2[ChainId2["UNICHAIN"] = 130] = "UNICHAIN";
  ChainId2[ChainId2["MONAD_TESTNET"] = 10143] = "MONAD_TESTNET";
  ChainId2[ChainId2["SONEIUM"] = 1868] = "SONEIUM";
})(ChainId || (ChainId = {}));
var SUPPORTED_CHAINS = [ChainId.MAINNET, ChainId.OPTIMISM, ChainId.OPTIMISM_GOERLI, ChainId.OPTIMISM_SEPOLIA, ChainId.ARBITRUM_ONE, ChainId.ARBITRUM_GOERLI, ChainId.ARBITRUM_SEPOLIA, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.GOERLI, ChainId.SEPOLIA, ChainId.CELO_ALFAJORES, ChainId.CELO, ChainId.BNB, ChainId.AVALANCHE, ChainId.BASE, ChainId.BASE_GOERLI, ChainId.BASE_SEPOLIA, ChainId.ZORA, ChainId.ZORA_SEPOLIA, ChainId.ROOTSTOCK, ChainId.BLAST, ChainId.ZKSYNC, ChainId.WORLDCHAIN, ChainId.UNICHAIN_SEPOLIA, ChainId.UNICHAIN, ChainId.MONAD_TESTNET, ChainId.SONEIUM];
var NativeCurrencyName;
(function(NativeCurrencyName2) {
  NativeCurrencyName2["ETHER"] = "ETH";
  NativeCurrencyName2["MATIC"] = "MATIC";
  NativeCurrencyName2["CELO"] = "CELO";
  NativeCurrencyName2["GNOSIS"] = "XDAI";
  NativeCurrencyName2["MOONBEAM"] = "GLMR";
  NativeCurrencyName2["BNB"] = "BNB";
  NativeCurrencyName2["AVAX"] = "AVAX";
  NativeCurrencyName2["ROOTSTOCK"] = "RBTC";
})(NativeCurrencyName || (NativeCurrencyName = {}));
var _V2_FACTORY_ADDRESSES;
var _V2_ROUTER_ADDRESSES;
var _CHAIN_TO_ADDRESSES_M;
var _GOVERNANCE_ALPHA_V1_;
var _GOVERNANCE_BRAVO_ADD;
var _MERKLE_DISTRIBUTOR_A;
var _ARGENT_WALLET_DETECT;
var _SOCKS_CONTROLLER_ADD;
var DEFAULT_NETWORKS = [ChainId.MAINNET, ChainId.GOERLI, ChainId.SEPOLIA];
function constructSameAddressMap(address, additionalNetworks) {
  if (additionalNetworks === void 0) {
    additionalNetworks = [];
  }
  return DEFAULT_NETWORKS.concat(additionalNetworks).reduce(function(memo, chainId) {
    memo[chainId] = address;
    return memo;
  }, {});
}
var UNI_ADDRESSES = constructSameAddressMap("0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", [ChainId.OPTIMISM, ChainId.ARBITRUM_ONE, ChainId.POLYGON, ChainId.POLYGON_MUMBAI, ChainId.SEPOLIA]);
var UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS = "0x8B799381ac40b838BBA4131ffB26197C432AFe78";
var V2_FACTORY_ADDRESS = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
var V2_FACTORY_ADDRESSES = (_V2_FACTORY_ADDRESSES = {}, _V2_FACTORY_ADDRESSES[ChainId.MAINNET] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.GOERLI] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.SEPOLIA] = "0xF62c03E08ada871A0bEb309762E260a7a6a880E6", _V2_FACTORY_ADDRESSES[ChainId.OPTIMISM] = "0x0c3c1c532F1e39EdF36BE9Fe0bE1410313E074Bf", _V2_FACTORY_ADDRESSES[ChainId.ARBITRUM_ONE] = "0xf1D7CC64Fb4452F05c498126312eBE29f30Fbcf9", _V2_FACTORY_ADDRESSES[ChainId.AVALANCHE] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", _V2_FACTORY_ADDRESSES[ChainId.BASE_SEPOLIA] = "0x7Ae58f10f7849cA6F5fB71b7f45CB416c9204b1e", _V2_FACTORY_ADDRESSES[ChainId.BASE] = "0x8909dc15e40173ff4699343b6eb8132c65e18ec6", _V2_FACTORY_ADDRESSES[ChainId.BNB] = "0x8909Dc15e40173Ff4699343b6eB8132c65e18eC6", _V2_FACTORY_ADDRESSES[ChainId.POLYGON] = "0x9e5A52f57b3038F1B8EeE45F28b3C1967e22799C", _V2_FACTORY_ADDRESSES[ChainId.CELO] = "0x79a530c8e2fA8748B7B40dd3629C0520c2cCf03f", _V2_FACTORY_ADDRESSES[ChainId.BLAST] = "0x5C346464d33F90bABaf70dB6388507CC889C1070", _V2_FACTORY_ADDRESSES[ChainId.WORLDCHAIN] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.UNICHAIN_SEPOLIA] = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f", _V2_FACTORY_ADDRESSES[ChainId.UNICHAIN] = "0x1f98400000000000000000000000000000000002", _V2_FACTORY_ADDRESSES[ChainId.MONAD_TESTNET] = "0x733e88f248b742db6c14c0b1713af5ad7fdd59d0", _V2_FACTORY_ADDRESSES[ChainId.SONEIUM] = "0x97febbc2adbd5644ba22736e962564b23f5828ce", _V2_FACTORY_ADDRESSES);
var V2_ROUTER_ADDRESS = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
var V2_ROUTER_ADDRESSES = (_V2_ROUTER_ADDRESSES = {}, _V2_ROUTER_ADDRESSES[ChainId.MAINNET] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", _V2_ROUTER_ADDRESSES[ChainId.GOERLI] = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D", _V2_ROUTER_ADDRESSES[ChainId.SEPOLIA] = "0xeE567Fe1712Faf6149d80dA1E6934E354124CfE3", _V2_ROUTER_ADDRESSES[ChainId.ARBITRUM_ONE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.OPTIMISM] = "0x4a7b5da61326a6379179b40d00f57e5bbdc962c2", _V2_ROUTER_ADDRESSES[ChainId.BASE_SEPOLIA] = "0x1689E7B1F10000AE47eBfE339a4f69dECd19F602", _V2_ROUTER_ADDRESSES[ChainId.BASE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.AVALANCHE] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.BNB] = "0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24", _V2_ROUTER_ADDRESSES[ChainId.POLYGON] = "0xedf6066a2b290c185783862c7f4776a2c8077ad1", _V2_ROUTER_ADDRESSES[ChainId.BLAST] = "0xBB66Eb1c5e875933D44DAe661dbD80e5D9B03035", _V2_ROUTER_ADDRESSES[ChainId.WORLDCHAIN] = "0x541aB7c31A119441eF3575F6973277DE0eF460bd", _V2_ROUTER_ADDRESSES[ChainId.UNICHAIN_SEPOLIA] = "0x920b806E40A00E02E7D2b94fFc89860fDaEd3640", _V2_ROUTER_ADDRESSES[ChainId.UNICHAIN] = "0x284f11109359a7e1306c3e447ef14d38400063ff", _V2_ROUTER_ADDRESSES[ChainId.MONAD_TESTNET] = "0xfb8e1c3b833f9e67a71c859a132cf783b645e436", _V2_ROUTER_ADDRESSES[ChainId.SONEIUM] = "0x273f68c234fa55b550b40e563c4a488e0d334320", _V2_ROUTER_ADDRESSES);
var DEFAULT_ADDRESSES = {
  v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  multicallAddress: "0x1F98415757620B543A52E61c46B32eB19261F984",
  quoterAddress: "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6",
  v3MigratorAddress: "0xA5644E29708357803b5A882D272c41cC0dF92B34",
  nonfungiblePositionManagerAddress: "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"
};
var MAINNET_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
  mixedRouteQuoterV1Address: "0x84E44095eeBfEC7793Cd7d5b57B7e401D7f1cA2E",
  v4PoolManagerAddress: "0x000000000004444c5dc75cB358380D2e3dE08A90",
  v4PositionManagerAddress: "0xbd216513d74c8cf14cf4747e6aaa6420ff64ee9e",
  v4StateView: "0x7ffe42c4a5deea5b0fec41c94c136cf115597227",
  v4QuoterAddress: "0x52f0e24d1c21c8a0cb1e5a5dd6198556bd9e1203"
});
var GOERLI_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
  mixedRouteQuoterV1Address: "0xBa60b6e6fF25488308789E6e0A65D838be34194e"
});
var OPTIMISM_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
  v4PoolManagerAddress: "0x9a13f98cb987694c9f086b1f5eb990eea8264ec3",
  v4PositionManagerAddress: "0x3c3ea4b57a46241e54610e5f022e5c45859a1017",
  v4StateView: "0xc18a3169788f4f75a170290584eca6395c75ecdb",
  v4QuoterAddress: "0x1f3131a13296fb91c90870043742c3cdbff1a8d7"
});
var ARBITRUM_ONE_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
  multicallAddress: "0xadF885960B47eA2CD9B55E6DAc6B42b7Cb2806dB",
  tickLensAddress: "0xbfd8137f7d1516D3ea5cA83523914859ec47F573",
  v4PoolManagerAddress: "0x360e68faccca8ca495c1b759fd9eee466db9fb32",
  v4PositionManagerAddress: "0xd88f38f930b7952f2db2432cb002e7abbf3dd869",
  v4StateView: "0x76fd297e2d437cd7f76d50f01afe6160f86e9990",
  v4QuoterAddress: "0x3972c00f7ed4885e145823eb7c655375d275a1c5"
});
var POLYGON_ADDRESSES = _extends({}, DEFAULT_ADDRESSES, {
  v4PoolManagerAddress: "0x67366782805870060151383f4bbff9dab53e5cd6",
  v4PositionManagerAddress: "0x1ec2ebf4f37e7363fdfe3551602425af0b3ceef9",
  v4StateView: "0x5ea1bd7974c8a611cbab0bdcafcb1d9cc9b3ba5a",
  v4QuoterAddress: "0xb3d5c3dfc3a7aebff71895a7191796bffc2c81b9"
});
var CELO_ADDRESSES = {
  v3CoreFactoryAddress: "0xAfE208a311B21f13EF87E33A90049fC17A7acDEc",
  multicallAddress: "0x633987602DE5C4F337e3DbF265303A1080324204",
  quoterAddress: "0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8",
  v3MigratorAddress: "0x3cFd4d48EDfDCC53D3f173F596f621064614C582",
  nonfungiblePositionManagerAddress: "0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A",
  tickLensAddress: "0x5f115D9113F88e0a0Db1b5033D90D4a9690AcD3D"
};
var BNB_ADDRESSES = {
  v3CoreFactoryAddress: "0xdB1d10011AD0Ff90774D0C6Bb92e5C5c8b4461F7",
  multicallAddress: "0x963Df249eD09c358A4819E39d9Cd5736c3087184",
  quoterAddress: "0x78D78E420Da98ad378D7799bE8f4AF69033EB077",
  v3MigratorAddress: "0x32681814957e0C13117ddc0c2aba232b5c9e760f",
  nonfungiblePositionManagerAddress: "0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613",
  tickLensAddress: "0xD9270014D396281579760619CCf4c3af0501A47C",
  swapRouter02Address: "0xB971eF87ede563556b2ED4b1C0b0019111Dd85d2",
  v4PoolManagerAddress: "0x28e2ea090877bf75740558f6bfb36a5ffee9e9df",
  v4PositionManagerAddress: "0x7a4a5c919ae2541aed11041a1aeee68f1287f95b",
  v4StateView: "0xd13dd3d6e93f276fafc9db9e6bb47c1180aee0c4",
  v4QuoterAddress: "0x9f75dd27d6664c475b90e105573e550ff69437b0"
};
var OPTIMISM_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0xB656dA17129e7EB733A557f4EBc57B76CFbB5d10",
  multicallAddress: "0x07F2D8a2a02251B62af965f22fC4744A5f96BCCd",
  quoterAddress: "0x9569CbA925c8ca2248772A9A4976A516743A246F",
  v3MigratorAddress: "0xf6c55fBe84B1C8c3283533c53F51bC32F5C7Aba8",
  nonfungiblePositionManagerAddress: "0x39Ca85Af2F383190cBf7d7c41ED9202D27426EF6",
  tickLensAddress: "0xe6140Bd164b63E8BfCfc40D5dF952f83e171758e"
};
var OPTIMISM_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x8CE191193D15ea94e11d327b4c7ad8bbE520f6aF",
  multicallAddress: "0x80e4e06841bb76AA9735E0448cB8d003C0EF009a",
  quoterAddress: "0x0FBEa6cf957d95ee9313490050F6A0DA68039404",
  v3MigratorAddress: "0xE7EcbAAaA54D007A00dbb6c1d2f150066D69dA07",
  nonfungiblePositionManagerAddress: "0xdA75cEf1C93078e8b736FCA5D5a30adb97C8957d",
  tickLensAddress: "0xCb7f54747F58F8944973cea5b8f4ac2209BadDC5",
  swapRouter02Address: "0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4"
};
var ARBITRUM_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0x4893376342d5D7b3e31d4184c08b265e5aB2A3f6",
  multicallAddress: "0x8260CB40247290317a4c062F3542622367F206Ee",
  quoterAddress: "0x1dd92b83591781D0C6d98d07391eea4b9a6008FA",
  v3MigratorAddress: "0xA815919D2584Ac3F76ea9CB62E6Fd40a43BCe0C3",
  nonfungiblePositionManagerAddress: "0x622e4726a167799826d1E1D150b076A7725f5D81",
  tickLensAddress: "0xb52429333da969a0C79a60930a4Bf0020E5D1DE8"
};
var ARBITRUM_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x248AB79Bbb9bC29bB72f7Cd42F17e054Fc40188e",
  multicallAddress: "0x2B718b475e385eD29F56775a66aAB1F5cC6B2A0A",
  quoterAddress: "0x2779a0CC1c3e0E44D2542EC3e79e3864Ae93Ef0B",
  v3MigratorAddress: "0x398f43ef2c67B941147157DA1c5a868E906E043D",
  nonfungiblePositionManagerAddress: "0x6b2937Bde17889EDCf8fbD8dE31C3C2a70Bc4d65",
  tickLensAddress: "0x0fd18587734e5C2dcE2dccDcC7DD1EC89ba557d9",
  swapRouter02Address: "0x101F443B4d1b059569D643917553c771E1b9663E",
  v4PoolManagerAddress: "0xFB3e0C6F74eB1a21CC1Da29aeC80D2Dfe6C9a317",
  v4PositionManagerAddress: "0xAc631556d3d4019C95769033B5E719dD77124BAc",
  v4StateView: "0x9d467fa9062b6e9b1a46e26007ad82db116c67cb",
  v4QuoterAddress: "0x7de51022d70a725b508085468052e25e22b5c4c9"
};
var SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x0227628f3F023bb0B980b67D528571c95c6DaC1c",
  multicallAddress: "0xD7F33bCdb21b359c8ee6F0251d30E94832baAd07",
  quoterAddress: "0xEd1f6473345F45b75F8179591dd5bA1888cf2FB3",
  v3MigratorAddress: "0x729004182cF005CEC8Bd85df140094b6aCbe8b15",
  nonfungiblePositionManagerAddress: "0x1238536071E1c677A632429e3655c799b22cDA52",
  tickLensAddress: "0xd7f33bcdb21b359c8ee6f0251d30e94832baad07",
  swapRouter02Address: "0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E",
  // TODO: update mixedRouteQuoterV2Address once v4 on sepolia redeployed
  mixedRouteQuoterV2Address: "0x4745f77b56a0e2294426e3936dc4fab68d9543cd",
  // TODO: update all below once v4 on sepolia redeployed
  v4PoolManagerAddress: "0xE03A1074c86CFeDd5C142C4F04F1a1536e203543",
  v4PositionManagerAddress: "0x429ba70129df741B2Ca2a85BC3A2a3328e5c09b4",
  v4StateView: "0xe1dd9c3fa50edb962e442f60dfbc432e24537e4c",
  v4QuoterAddress: "0x61b3f2011a92d183c7dbadbda940a7555ccf9227"
};
var AVALANCHE_ADDRESSES = {
  v3CoreFactoryAddress: "0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD",
  multicallAddress: "0x0139141Cd4Ee88dF3Cdb65881D411bAE271Ef0C2",
  quoterAddress: "0xbe0F5544EC67e9B3b2D979aaA43f18Fd87E6257F",
  v3MigratorAddress: "0x44f5f1f5E452ea8d29C890E8F6e893fC0f1f0f97",
  nonfungiblePositionManagerAddress: "0x655C406EBFa14EE2006250925e54ec43AD184f8B",
  tickLensAddress: "0xEB9fFC8bf81b4fFd11fb6A63a6B0f098c6e21950",
  swapRouter02Address: "0xbb00FF08d01D300023C629E8fFfFcb65A5a578cE",
  v4PoolManagerAddress: "0x06380c0e0912312b5150364b9dc4542ba0dbbc85",
  v4PositionManagerAddress: "0xb74b1f14d2754acfcbbe1a221023a5cf50ab8acd",
  v4StateView: "0xc3c9e198c735a4b97e3e683f391ccbdd60b69286",
  v4QuoterAddress: "0xbe40675bb704506a3c2ccfb762dcfd1e979845c2"
};
var BASE_ADDRESSES = {
  v3CoreFactoryAddress: "0x33128a8fC17869897dcE68Ed026d694621f6FDfD",
  multicallAddress: "0x091e99cb1C49331a94dD62755D168E941AbD0693",
  quoterAddress: "0x3d4e44Eb1374240CE5F1B871ab261CD16335B76a",
  v3MigratorAddress: "0x23cF10b1ee3AdfCA73B0eF17C07F7577e7ACd2d7",
  nonfungiblePositionManagerAddress: "0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1",
  tickLensAddress: "0x0CdeE061c75D43c82520eD998C23ac2991c9ac6d",
  swapRouter02Address: "0x2626664c2603336E57B271c5C0b26F421741e481",
  mixedRouteQuoterV1Address: "0xe544efae946f0008ae9a8d64493efa7886b73776",
  v4PoolManagerAddress: "0x498581ff718922c3f8e6a244956af099b2652b2b",
  v4PositionManagerAddress: "0x7c5f5a4bbd8fd63184577525326123b519429bdc",
  v4StateView: "0xa3c0c9b65bad0b08107aa264b0f3db444b867a71",
  v4QuoterAddress: "0x0d5e0f971ed27fbff6c2837bf31316121532048d"
};
var BASE_GOERLI_ADDRESSES = {
  v3CoreFactoryAddress: "0x9323c1d6D800ed51Bd7C6B216cfBec678B7d0BC2",
  multicallAddress: "0xB206027a9E0E13F05eBEFa5D2402Bab3eA716439",
  quoterAddress: "0xedf539058e28E5937dAef3f69cEd0b25fbE66Ae9",
  v3MigratorAddress: "0x3efe5d02a04b7351D671Db7008ec6eBA9AD9e3aE",
  nonfungiblePositionManagerAddress: "0x3c61369ef0D1D2AFa70d8feC2F31C5D6Ce134F30",
  tickLensAddress: "0x1acB873Ee909D0c98adB18e4474943249F931b92",
  swapRouter02Address: "0x8357227D4eDc78991Db6FDB9bD6ADE250536dE1d"
};
var BASE_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x4752ba5DBc23f44D87826276BF6Fd6b1C372aD24",
  multicallAddress: "0xd867e273eAbD6c853fCd0Ca0bFB6a3aE6491d2C1",
  quoterAddress: "0xC5290058841028F1614F3A6F0F5816cAd0df5E27",
  v3MigratorAddress: "0xCbf8b7f80800bd4888Fbc7bf1713B80FE4E23E10",
  nonfungiblePositionManagerAddress: "0x27F971cb582BF9E50F397e4d29a5C7A34f11faA2",
  tickLensAddress: "0xedf6066a2b290C185783862C7F4776A2C8077AD1",
  swapRouter02Address: "0x94cC0AaC535CCDB3C01d6787D6413C739ae12bc4",
  // v4
  v4PoolManagerAddress: "0x05E73354cFDd6745C338b50BcFDfA3Aa6fA03408",
  v4PositionManagerAddress: "0x4b2c77d209d3405f41a037ec6c77f7f5b8e2ca80",
  v4StateView: "0x571291b572ed32ce6751a2cb2486ebee8defb9b4",
  v4QuoterAddress: "0x4a6513c898fe1b2d0e78d3b0e0a4a151589b1cba"
};
var ZORA_ADDRESSES = {
  v3CoreFactoryAddress: "0x7145F8aeef1f6510E92164038E1B6F8cB2c42Cbb",
  multicallAddress: "0xA51c76bEE6746cB487a7e9312E43e2b8f4A37C15",
  quoterAddress: "0x11867e1b3348F3ce4FcC170BC5af3d23E07E64Df",
  v3MigratorAddress: "0x048352d8dCF13686982C799da63fA6426a9D0b60",
  nonfungiblePositionManagerAddress: "0xbC91e8DfA3fF18De43853372A3d7dfe585137D78",
  tickLensAddress: "0x209AAda09D74Ad3B8D0E92910Eaf85D2357e3044",
  swapRouter02Address: "0x7De04c96BE5159c3b5CeffC82aa176dc81281557",
  v4PoolManagerAddress: "0x0575338e4c17006ae181b47900a84404247ca30f",
  v4PositionManagerAddress: "0xf66c7b99e2040f0d9b326b3b7c152e9663543d63",
  v4StateView: "0x385785af07d63b50d0a0ea57c4ff89d06adf7328",
  v4QuoterAddress: "0x5edaccc0660e0a2c44b06e07ce8b915e625dc2c6"
};
var ZORA_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x4324A677D74764f46f33ED447964252441aA8Db6",
  multicallAddress: "0xA1E7e3A69671C4494EC59Dbd442de930a93F911A",
  quoterAddress: "0xC195976fEF0985886E37036E2DF62bF371E12Df0",
  v3MigratorAddress: "0x65ef259b31bf1d977c37e9434658694267674897",
  nonfungiblePositionManagerAddress: "0xB8458EaAe43292e3c1F7994EFd016bd653d23c20",
  tickLensAddress: "0x23C0F71877a1Fc4e20A78018f9831365c85f3064"
};
var ROOTSTOCK_ADDRESSES = {
  v3CoreFactoryAddress: "0xaF37EC98A00FD63689CF3060BF3B6784E00caD82",
  multicallAddress: "0x996a9858cDfa45Ad68E47c9A30a7201E29c6a386",
  quoterAddress: "0xb51727c996C68E60F598A923a5006853cd2fEB31",
  v3MigratorAddress: "0x16678977CA4ec3DAD5efc7b15780295FE5f56162",
  nonfungiblePositionManagerAddress: "0x9d9386c042F194B460Ec424a1e57ACDE25f5C4b1",
  tickLensAddress: "0x55B9dF5bF68ADe972191a91980459f48ecA16afC",
  swapRouter02Address: "0x0B14ff67f0014046b4b99057Aec4509640b3947A"
};
var BLAST_ADDRESSES = {
  v3CoreFactoryAddress: "0x792edAdE80af5fC680d96a2eD80A44247D2Cf6Fd",
  multicallAddress: "0xdC7f370de7631cE9e2c2e1DCDA6B3B5744Cf4705",
  quoterAddress: "0x6Cdcd65e03c1CEc3730AeeCd45bc140D57A25C77",
  v3MigratorAddress: "0x15CA7043CD84C5D21Ae76Ba0A1A967d42c40ecE0",
  nonfungiblePositionManagerAddress: "0xB218e4f7cF0533d4696fDfC419A0023D33345F28",
  tickLensAddress: "0x2E95185bCdD928a3e984B7e2D6560Ab1b17d7274",
  swapRouter02Address: "0x549FEB8c9bd4c12Ad2AB27022dA12492aC452B66",
  v4PoolManagerAddress: "0x1631559198a9e474033433b2958dabc135ab6446",
  v4PositionManagerAddress: "0x4ad2f4cca2682cbb5b950d660dd458a1d3f1baad",
  v4StateView: "0x12a88ae16f46dce4e8b15368008ab3380885df30",
  v4QuoterAddress: "0x6f71cdcb0d119ff72c6eb501abceb576fbf62bcf"
};
var ZKSYNC_ADDRESSES = {
  v3CoreFactoryAddress: "0x8FdA5a7a8dCA67BBcDd10F02Fa0649A937215422",
  multicallAddress: "0x0c68a7C72f074d1c45C16d41fa74eEbC6D16a65C",
  quoterAddress: "0x8Cb537fc92E26d8EBBb760E632c95484b6Ea3e28",
  v3MigratorAddress: "0x611841b24E43C4ACfd290B427a3D6cf1A59dac8E",
  nonfungiblePositionManagerAddress: "0x0616e5762c1E7Dc3723c50663dF10a162D690a86",
  tickLensAddress: "0xe10FF11b809f8EE07b056B452c3B2caa7FE24f89",
  swapRouter02Address: "0x99c56385daBCE3E81d8499d0b8d0257aBC07E8A3"
};
var WORLDCHAIN_ADDRESSES = {
  v3CoreFactoryAddress: "0x7a5028BDa40e7B173C278C5342087826455ea25a",
  multicallAddress: "0x0a22c04215c97E3F532F4eF30e0aD9458792dAB9",
  quoterAddress: "0x10158D43e6cc414deE1Bd1eB0EfC6a5cBCfF244c",
  v3MigratorAddress: "0x9EBDdCBa71C9027E1eB45135672a30bcFEec9de3",
  nonfungiblePositionManagerAddress: "0xec12a9F9a09f50550686363766Cc153D03c27b5e",
  tickLensAddress: "0xE61df0CaC9d85876aCE5E3037005D80943570623",
  swapRouter02Address: "0x091AD9e2e6e5eD44c1c66dB50e49A601F9f36cF6",
  v4PoolManagerAddress: "0xb1860d529182ac3bc1f51fa2abd56662b7d13f33",
  v4PositionManagerAddress: "0xc585e0f504613b5fbf874f21af14c65260fb41fa",
  v4StateView: "0x51d394718bc09297262e368c1a481217fdeb71eb",
  v4QuoterAddress: "0x55d235b3ff2daf7c3ede0defc9521f1d6fe6c5c0"
};
var UNICHAIN_SEPOLIA_ADDRESSES = {
  v3CoreFactoryAddress: "0x1F98431c8aD98523631AE4a59f267346ea31F984",
  multicallAddress: "0x9D0F15f2cf58655fDDcD1EE6129C547fDaeD01b1",
  quoterAddress: "0x6Dd37329A1A225a6Fca658265D460423DCafBF89",
  v3MigratorAddress: "0xb5FA244C9d6D04B2FBac84418b3c4910ED1Ae5f2",
  nonfungiblePositionManagerAddress: "0xB7F724d6dDDFd008eFf5cc2834edDE5F9eF0d075",
  tickLensAddress: "0x5f739c790a48E97eec0efb81bab5D152c0A0ecA0",
  swapRouter02Address: "0xd1AAE39293221B77B0C71fBD6dCb7Ea29Bb5B166",
  v4PoolManagerAddress: "0x00b036b58a818b1bc34d502d3fe730db729e62ac",
  v4PositionManagerAddress: "0xf969aee60879c54baaed9f3ed26147db216fd664",
  v4StateView: "0xc199f1072a74d4e905aba1a84d9a45e2546b6222",
  v4QuoterAddress: "0x56dcd40a3f2d466f48e7f48bdbe5cc9b92ae4472"
};
var UNICHAIN_ADDRESSES = {
  v3CoreFactoryAddress: "0x1f98400000000000000000000000000000000003",
  multicallAddress: "0xb7610f9b733e7d45184be3a1bc966960ccc54f0b",
  quoterAddress: "0x565ac8c7863d9bb16d07e809ff49fe5cd467634c",
  v3MigratorAddress: "0xb9d0c246f306b1aaf02ae6ba112d5ef25e5b60dc",
  nonfungiblePositionManagerAddress: "0x943e6e07a7e8e791dafc44083e54041d743c46e9",
  tickLensAddress: "0xd5d76fa166ab8d8ad4c9f61aaa81457b66cbe443",
  swapRouter02Address: "0x73855d06de49d0fe4a9c42636ba96c62da12ff9c",
  v4PoolManagerAddress: "0x1f98400000000000000000000000000000000004",
  v4PositionManagerAddress: "0x4529a01c7a0410167c5740c487a8de60232617bf",
  v4StateView: "0x86e8631a016f9068c3f085faf484ee3f5fdee8f2",
  v4QuoterAddress: "0x333e3c607b141b18ff6de9f258db6e77fe7491e0"
};
var MONAD_TESTNET_ADDRESSES = {
  v3CoreFactoryAddress: "0x961235a9020b05c44df1026d956d1f4d78014276",
  multicallAddress: "0xa707ceb989cc3728551ed0e6e44b718dd114cf44",
  quoterAddress: "0x1ba215c17565de7b0cb7ecab971bcf540c24a862",
  v3MigratorAddress: "0x0a78348b71f8ae8caff2f8f9d4d74a2f36516661",
  nonfungiblePositionManagerAddress: "0x3dcc735c74f10fe2b9db2bb55c40fbbbf24490f7",
  tickLensAddress: "0x337478eb6058455ecb3696184b30dd6a29e3a893",
  swapRouter02Address: "0x4c4eabd5fb1d1a7234a48692551eaecff8194ca7"
};
var SONEIUM_ADDRESSES = {
  v3CoreFactoryAddress: "0x42ae7ec7ff020412639d443e245d936429fbe717",
  multicallAddress: "0x8ad5ef2f2508288d2de66f04dd883ad5f4ef62b2",
  quoterAddress: "0x3e6c707d0125226ff60f291b6bd1404634f00aba",
  v3MigratorAddress: "0xa107580f73bd797bd8b87ff24e98346d99f93ddb",
  nonfungiblePositionManagerAddress: "0x56c1205b0244332011c1e866f4ea5384eb6bfa2c",
  tickLensAddress: "0xcd08eefb928c86499e6235ac155906bb7c4dc41a",
  swapRouter02Address: "0x7e40db01736f88464e5f4e42394f3d5bbb6705b9",
  v4PoolManagerAddress: "0x360e68faccca8ca495c1b759fd9eee466db9fb32",
  v4PositionManagerAddress: "0x1b35d13a2e2528f192637f14b05f0dc0e7deb566",
  v4StateView: "0x76fd297e2d437cd7f76d50f01afe6160f86e9990",
  v4QuoterAddress: "0x3972c00f7ed4885e145823eb7c655375d275a1c5"
};
var CHAIN_TO_ADDRESSES_MAP = (_CHAIN_TO_ADDRESSES_M = {}, _CHAIN_TO_ADDRESSES_M[ChainId.MAINNET] = MAINNET_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM] = OPTIMISM_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_ONE] = ARBITRUM_ONE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.POLYGON_MUMBAI] = POLYGON_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.GOERLI] = GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.CELO_ALFAJORES] = CELO_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BNB] = BNB_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_GOERLI] = OPTIMISM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.OPTIMISM_SEPOLIA] = OPTIMISM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_GOERLI] = ARBITRUM_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ARBITRUM_SEPOLIA] = ARBITRUM_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.SEPOLIA] = SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.AVALANCHE] = AVALANCHE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE] = BASE_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE_GOERLI] = BASE_GOERLI_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BASE_SEPOLIA] = BASE_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ZORA] = ZORA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ZORA_SEPOLIA] = ZORA_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ROOTSTOCK] = ROOTSTOCK_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.BLAST] = BLAST_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.ZKSYNC] = ZKSYNC_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.WORLDCHAIN] = WORLDCHAIN_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.UNICHAIN_SEPOLIA] = UNICHAIN_SEPOLIA_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.UNICHAIN] = UNICHAIN_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.MONAD_TESTNET] = MONAD_TESTNET_ADDRESSES, _CHAIN_TO_ADDRESSES_M[ChainId.SONEIUM] = SONEIUM_ADDRESSES, _CHAIN_TO_ADDRESSES_M);
var V3_CORE_FACTORY_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].v3CoreFactoryAddress;
  return memo;
}, {}));
var V3_MIGRATOR_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  var v3MigratorAddress = CHAIN_TO_ADDRESSES_MAP[chainId].v3MigratorAddress;
  if (v3MigratorAddress) {
    memo[chainId] = v3MigratorAddress;
  }
  return memo;
}, {}));
var MULTICALL_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].multicallAddress;
  return memo;
}, {}));
var GOVERNANCE_ALPHA_V0_ADDRESSES = constructSameAddressMap("0x5e4be8Bc9637f0EAA1A755019e06A68ce081D58F");
var GOVERNANCE_ALPHA_V1_ADDRESSES = (_GOVERNANCE_ALPHA_V1_ = {}, _GOVERNANCE_ALPHA_V1_[ChainId.MAINNET] = "0xC4e172459f1E7939D522503B81AFAaC1014CE6F6", _GOVERNANCE_ALPHA_V1_);
var GOVERNANCE_BRAVO_ADDRESSES = (_GOVERNANCE_BRAVO_ADD = {}, _GOVERNANCE_BRAVO_ADD[ChainId.MAINNET] = "0x408ED6354d4973f66138C91495F2f2FCbd8724C3", _GOVERNANCE_BRAVO_ADD);
var TIMELOCK_ADDRESSES = constructSameAddressMap("0x1a9C8182C09F50C8318d769245beA52c32BE35BC");
var MERKLE_DISTRIBUTOR_ADDRESS = (_MERKLE_DISTRIBUTOR_A = {}, _MERKLE_DISTRIBUTOR_A[ChainId.MAINNET] = "0x090D4613473dEE047c3f2706764f49E0821D256e", _MERKLE_DISTRIBUTOR_A);
var ARGENT_WALLET_DETECTOR_ADDRESS = (_ARGENT_WALLET_DETECT = {}, _ARGENT_WALLET_DETECT[ChainId.MAINNET] = "0xeca4B0bDBf7c55E9b7925919d03CbF8Dc82537E8", _ARGENT_WALLET_DETECT);
var QUOTER_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  memo[chainId] = CHAIN_TO_ADDRESSES_MAP[chainId].quoterAddress;
  return memo;
}, {}));
var NONFUNGIBLE_POSITION_MANAGER_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  var nonfungiblePositionManagerAddress = CHAIN_TO_ADDRESSES_MAP[chainId].nonfungiblePositionManagerAddress;
  if (nonfungiblePositionManagerAddress) {
    memo[chainId] = nonfungiblePositionManagerAddress;
  }
  return memo;
}, {}));
var ENS_REGISTRAR_ADDRESSES = _extends({}, constructSameAddressMap("0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"));
var SOCKS_CONTROLLER_ADDRESSES = (_SOCKS_CONTROLLER_ADD = {}, _SOCKS_CONTROLLER_ADD[ChainId.MAINNET] = "0x65770b5283117639760beA3F867b69b3697a91dd", _SOCKS_CONTROLLER_ADD);
var TICK_LENS_ADDRESSES = _extends({}, SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  var tickLensAddress = CHAIN_TO_ADDRESSES_MAP[chainId].tickLensAddress;
  if (tickLensAddress) {
    memo[chainId] = tickLensAddress;
  }
  return memo;
}, {}));
var MIXED_ROUTE_QUOTER_V1_ADDRESSES = SUPPORTED_CHAINS.reduce(function(memo, chainId) {
  var mixedRouteQuoterV1Address = CHAIN_TO_ADDRESSES_MAP[chainId].mixedRouteQuoterV1Address;
  if (mixedRouteQuoterV1Address) {
    memo[chainId] = mixedRouteQuoterV1Address;
  }
  return memo;
}, {});
var SWAP_ROUTER_02_ADDRESSES = function SWAP_ROUTER_02_ADDRESSES2(chainId) {
  if (SUPPORTED_CHAINS.includes(chainId)) {
    var _CHAIN_TO_ADDRESSES_M2;
    var id = chainId;
    return (_CHAIN_TO_ADDRESSES_M2 = CHAIN_TO_ADDRESSES_MAP[id].swapRouter02Address) != null ? _CHAIN_TO_ADDRESSES_M2 : "0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45";
  }
  return "";
};
var TradeType;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType || (TradeType = {}));
var Rounding;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));
var MaxUint256 = jsbi_default.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _toSignificantRoundin;
var _toFixedRounding;
var Decimal2 = (0, import_toformat.default)(decimal_default);
var Big2 = (0, import_toformat.default)(big_default);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal2.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal2.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal2.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = jsbi_default.BigInt(1);
    }
    this.numerator = jsbi_default.BigInt(numerator);
    this.denominator = jsbi_default.BigInt(denominator);
  }
  Fraction2.tryParseFraction = function tryParseFraction(fractionish) {
    if (fractionish instanceof jsbi_default || typeof fractionish === "number" || typeof fractionish === "string") return new Fraction2(fractionish);
    if ("numerator" in fractionish && "denominator" in fractionish) return fractionish;
    throw new Error("Could not parse fraction");
  };
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(jsbi_default.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(jsbi_default.add(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(jsbi_default.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(jsbi_default.subtract(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return jsbi_default.lessThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return jsbi_default.equal(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return jsbi_default.greaterThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.numerator), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = Fraction2.tryParseFraction(other);
    return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? true ? invariant(false, significantDigits + " is not an integer.") : invariant(false) : void 0;
    !(significantDigits > 0) ? true ? invariant(false, significantDigits + " is not positive.") : invariant(false) : void 0;
    Decimal2.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? true ? invariant(false, decimalPlaces + " is not an integer.") : invariant(false) : void 0;
    !(decimalPlaces >= 0) ? true ? invariant(false, decimalPlaces + " is negative.") : invariant(false) : void 0;
    Big2.DP = decimalPlaces;
    Big2.RM = toFixedRounding[rounding];
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  return _createClass(Fraction2, [{
    key: "quotient",
    get: function get() {
      return jsbi_default.divide(this.numerator, this.denominator);
    }
    // remainder after floor division
  }, {
    key: "remainder",
    get: function get() {
      return new Fraction2(jsbi_default.remainder(this.numerator, this.denominator), this.denominator);
    }
  }, {
    key: "asFraction",
    get: function get() {
      return new Fraction2(this.numerator, this.denominator);
    }
  }]);
}();
var Big$1 = (0, import_toformat.default)(big_default);
var CurrencyAmount = function(_Fraction) {
  function CurrencyAmount2(currency, numerator, denominator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    !jsbi_default.lessThanOrEqual(_this.quotient, MaxUint256) ? true ? invariant(false, "AMOUNT") : invariant(false) : void 0;
    _this.currency = currency;
    _this.decimalScale = jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(currency.decimals));
    return _this;
  }
  _inheritsLoose(CurrencyAmount2, _Fraction);
  CurrencyAmount2.fromRawAmount = function fromRawAmount(currency, rawAmount) {
    return new CurrencyAmount2(currency, rawAmount);
  };
  CurrencyAmount2.fromFractionalAmount = function fromFractionalAmount(currency, numerator, denominator) {
    return new CurrencyAmount2(currency, numerator, denominator);
  };
  var _proto = CurrencyAmount2.prototype;
  _proto.add = function add2(other) {
    !this.currency.equals(other.currency) ? true ? invariant(false, "CURRENCY") : invariant(false) : void 0;
    var added = _Fraction.prototype.add.call(this, other);
    return CurrencyAmount2.fromFractionalAmount(this.currency, added.numerator, added.denominator);
  };
  _proto.subtract = function subtract2(other) {
    !this.currency.equals(other.currency) ? true ? invariant(false, "CURRENCY") : invariant(false) : void 0;
    var subtracted = _Fraction.prototype.subtract.call(this, other);
    return CurrencyAmount2.fromFractionalAmount(this.currency, subtracted.numerator, subtracted.denominator);
  };
  _proto.multiply = function multiply(other) {
    var multiplied = _Fraction.prototype.multiply.call(this, other);
    return CurrencyAmount2.fromFractionalAmount(this.currency, multiplied.numerator, multiplied.denominator);
  };
  _proto.divide = function divide2(other) {
    var divided = _Fraction.prototype.divide.call(this, other);
    return CurrencyAmount2.fromFractionalAmount(this.currency, divided.numerator, divided.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    return _Fraction.prototype.divide.call(this, this.decimalScale).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? true ? invariant(false, "DECIMALS") : invariant(false) : void 0;
    return _Fraction.prototype.divide.call(this, this.decimalScale).toFixed(decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1.DP = this.currency.decimals;
    return new Big$1(this.quotient.toString()).div(this.decimalScale.toString()).toFormat(format);
  };
  return _createClass(CurrencyAmount2, [{
    key: "wrapped",
    get: function get() {
      if (this.currency.isToken) return this;
      return CurrencyAmount2.fromFractionalAmount(this.currency.wrapped, this.numerator, this.denominator);
    }
  }]);
}(Fraction);
var ONE_HUNDRED = new Fraction(jsbi_default.BigInt(100));
function toPercent(fraction) {
  return new Percent(fraction.numerator, fraction.denominator);
}
var Percent = function(_Fraction) {
  function Percent2() {
    var _this;
    _this = _Fraction.apply(this, arguments) || this;
    _this.isPercent = true;
    return _this;
  }
  _inheritsLoose(Percent2, _Fraction);
  var _proto = Percent2.prototype;
  _proto.add = function add2(other) {
    return toPercent(_Fraction.prototype.add.call(this, other));
  };
  _proto.subtract = function subtract2(other) {
    return toPercent(_Fraction.prototype.subtract.call(this, other));
  };
  _proto.multiply = function multiply(other) {
    return toPercent(_Fraction.prototype.multiply.call(this, other));
  };
  _proto.divide = function divide2(other) {
    return toPercent(_Fraction.prototype.divide.call(this, other));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return _Fraction.prototype.multiply.call(this, ONE_HUNDRED).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction);
var Price = function(_Fraction) {
  function Price2() {
    var _this;
    var baseCurrency, quoteCurrency, denominator, numerator;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 4) {
      baseCurrency = args[0];
      quoteCurrency = args[1];
      denominator = args[2];
      numerator = args[3];
    } else {
      var result = args[0].quoteAmount.divide(args[0].baseAmount);
      var _ref = [args[0].baseAmount.currency, args[0].quoteAmount.currency, result.denominator, result.numerator];
      baseCurrency = _ref[0];
      quoteCurrency = _ref[1];
      denominator = _ref[2];
      numerator = _ref[3];
    }
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction(jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(baseCurrency.decimals)), jsbi_default.exponentiate(jsbi_default.BigInt(10), jsbi_default.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  _inheritsLoose(Price2, _Fraction);
  var _proto = Price2.prototype;
  _proto.invert = function invert() {
    return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  };
  _proto.multiply = function multiply(other) {
    !this.quoteCurrency.equals(other.baseCurrency) ? true ? invariant(false, "TOKEN") : invariant(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  };
  _proto.quote = function quote(currencyAmount) {
    !currencyAmount.currency.equals(this.baseCurrency) ? true ? invariant(false, "TOKEN") : invariant(false) : void 0;
    var result = _Fraction.prototype.multiply.call(this, currencyAmount);
    return CurrencyAmount.fromFractionalAmount(this.quoteCurrency, result.numerator, result.denominator);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjustedForDecimals.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjustedForDecimals.toFixed(decimalPlaces, format, rounding);
  };
  return _createClass(Price2, [{
    key: "adjustedForDecimals",
    get: function get() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
}(Fraction);
var BaseCurrency = (
  /**
   * Constructs an instance of the base class `BaseCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  function BaseCurrency2(chainId, decimals, symbol, name) {
    !Number.isSafeInteger(chainId) ? true ? invariant(false, "CHAIN_ID") : invariant(false) : void 0;
    !(decimals >= 0 && decimals < 255 && Number.isInteger(decimals)) ? true ? invariant(false, "DECIMALS") : invariant(false) : void 0;
    this.chainId = chainId;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
  }
);
var NativeCurrency = function(_BaseCurrency) {
  function NativeCurrency2() {
    var _this;
    _this = _BaseCurrency.apply(this, arguments) || this;
    _this.isNative = true;
    _this.isToken = false;
    return _this;
  }
  _inheritsLoose(NativeCurrency2, _BaseCurrency);
  return NativeCurrency2;
}(BaseCurrency);
function validateAndParseAddress(address) {
  try {
    return getAddress(address);
  } catch (error) {
    throw new Error(address + " is not a valid address.");
  }
}
var startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;
function checkValidAddress(address) {
  if (startsWith0xLen42HexRegex.test(address)) {
    return address;
  }
  throw new Error(address + " is not a valid address.");
}
var Token = function(_BaseCurrency) {
  function Token2(chainId, address, decimals, symbol, name, bypassChecksum, buyFeeBps, sellFeeBps) {
    var _this;
    _this = _BaseCurrency.call(this, chainId, decimals, symbol, name) || this;
    _this.isNative = false;
    _this.isToken = true;
    if (bypassChecksum) {
      _this.address = checkValidAddress(address);
    } else {
      _this.address = validateAndParseAddress(address);
    }
    if (buyFeeBps) {
      !buyFeeBps.gte(BigNumber.from(0)) ? true ? invariant(false, "NON-NEGATIVE FOT FEES") : invariant(false) : void 0;
    }
    if (sellFeeBps) {
      !sellFeeBps.gte(BigNumber.from(0)) ? true ? invariant(false, "NON-NEGATIVE FOT FEES") : invariant(false) : void 0;
    }
    _this.buyFeeBps = buyFeeBps;
    _this.sellFeeBps = sellFeeBps;
    return _this;
  }
  _inheritsLoose(Token2, _BaseCurrency);
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    return other.isToken && this.chainId === other.chainId && this.address.toLowerCase() === other.address.toLowerCase();
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? true ? invariant(false, "CHAIN_IDS") : invariant(false) : void 0;
    !(this.address.toLowerCase() !== other.address.toLowerCase()) ? true ? invariant(false, "ADDRESSES") : invariant(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  return _createClass(Token2, [{
    key: "wrapped",
    get: function get() {
      return this;
    }
  }]);
}(BaseCurrency);
var WETH9 = {
  1: new Token(1, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"),
  11155111: new Token(11155111, "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14", 18, "WETH", "Wrapped Ether"),
  3: new Token(3, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  4: new Token(4, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"),
  5: new Token(5, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"),
  42: new Token(42, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"),
  10: new Token(10, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  69: new Token(69, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  11155420: new Token(11155420, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  42161: new Token(42161, "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", 18, "WETH", "Wrapped Ether"),
  421611: new Token(421611, "0xB47e6A5f8b33b3F17603C83a0535A9dcD7E32681", 18, "WETH", "Wrapped Ether"),
  421614: new Token(421614, "0x980B62Da83eFf3D4576C647993b0c1D7faf17c73", 18, "WETH", "Wrapped Ether"),
  8453: new Token(8453, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  84532: new Token(84532, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  56: new Token(56, "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c", 18, "WBNB", "Wrapped BNB"),
  137: new Token(137, "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270", 18, "WMATIC", "Wrapped MATIC"),
  43114: new Token(43114, "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7", 18, "WAVAX", "Wrapped AVAX"),
  7777777: new Token(7777777, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  81457: new Token(81457, "0x4300000000000000000000000000000000000004", 18, "WETH", "Wrapped Ether"),
  324: new Token(324, "0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91", 18, "WETH", "Wrapped Ether"),
  480: new Token(480, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  1301: new Token(1301, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  130: new Token(130, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether"),
  10143: new Token(10143, "0x760AfE86e5de5fa0Ee542fc7B7B713e1c5425701", 18, "WMON", "Wrapped Monad"),
  1868: new Token(1868, "0x4200000000000000000000000000000000000006", 18, "WETH", "Wrapped Ether")
};
var Ether = function(_NativeCurrency) {
  function Ether2(chainId) {
    return _NativeCurrency.call(this, chainId, 18, "ETH", "Ether") || this;
  }
  _inheritsLoose(Ether2, _NativeCurrency);
  Ether2.onChain = function onChain(chainId) {
    var _this$_etherCache$cha;
    return (_this$_etherCache$cha = this._etherCache[chainId]) != null ? _this$_etherCache$cha : this._etherCache[chainId] = new Ether2(chainId);
  };
  var _proto = Ether2.prototype;
  _proto.equals = function equals(other) {
    return other.isNative && other.chainId === this.chainId;
  };
  return _createClass(Ether2, [{
    key: "wrapped",
    get: function get() {
      var weth9 = WETH9[this.chainId];
      !!!weth9 ? true ? invariant(false, "WRAPPED") : invariant(false) : void 0;
      return weth9;
    }
  }]);
}(NativeCurrency);
Ether._etherCache = {};
function computePriceImpact(midPrice, inputAmount, outputAmount) {
  var quotedOutputAmount = midPrice.quote(inputAmount);
  var priceImpact = quotedOutputAmount.subtract(outputAmount).divide(quotedOutputAmount);
  return new Percent(priceImpact.numerator, priceImpact.denominator);
}
function computeZksyncCreate2Address(sender, bytecodeHash, salt, input) {
  if (input === void 0) {
    input = "0x";
  }
  var prefix2 = keccak256(toUtf8Bytes("zksyncCreate2"));
  var inputHash = keccak256(input);
  var addressBytes = keccak256(concat([prefix2, hexZeroPad(sender, 32), salt, bytecodeHash, inputHash])).slice(26);
  return getAddress(addressBytes);
}
function sortedInsert(items, add2, maxSize, comparator) {
  !(maxSize > 0) ? true ? invariant(false, "MAX_SIZE_ZERO") : invariant(false) : void 0;
  !(items.length <= maxSize) ? true ? invariant(false, "ITEMS_SIZE") : invariant(false) : void 0;
  if (items.length === 0) {
    items.push(add2);
    return null;
  } else {
    var isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add2) <= 0) {
      return add2;
    }
    var lo = 0, hi = items.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (comparator(items[mid], add2) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add2);
    return isFull ? items.pop() : null;
  }
}
var MAX_SAFE_INTEGER2 = jsbi_default.BigInt(Number.MAX_SAFE_INTEGER);
var ZERO = jsbi_default.BigInt(0);
var ONE2 = jsbi_default.BigInt(1);
var TWO = jsbi_default.BigInt(2);
function sqrt(value) {
  !jsbi_default.greaterThanOrEqual(value, ZERO) ? true ? invariant(false, "NEGATIVE") : invariant(false) : void 0;
  if (jsbi_default.lessThan(value, MAX_SAFE_INTEGER2)) {
    return jsbi_default.BigInt(Math.floor(Math.sqrt(jsbi_default.toNumber(value))));
  }
  var z;
  var x;
  z = value;
  x = jsbi_default.add(jsbi_default.divide(value, TWO), ONE2);
  while (jsbi_default.lessThan(x, z)) {
    z = x;
    x = jsbi_default.divide(jsbi_default.add(jsbi_default.divide(value, x), x), TWO);
  }
  return z;
}

export {
  jsbi_default,
  invariant,
  ChainId,
  SUPPORTED_CHAINS,
  NativeCurrencyName,
  UNI_ADDRESSES,
  UNISWAP_NFT_AIRDROP_CLAIM_ADDRESS,
  V2_FACTORY_ADDRESS,
  V2_FACTORY_ADDRESSES,
  V2_ROUTER_ADDRESS,
  V2_ROUTER_ADDRESSES,
  CHAIN_TO_ADDRESSES_MAP,
  V3_CORE_FACTORY_ADDRESSES,
  V3_MIGRATOR_ADDRESSES,
  MULTICALL_ADDRESSES,
  GOVERNANCE_ALPHA_V0_ADDRESSES,
  GOVERNANCE_ALPHA_V1_ADDRESSES,
  GOVERNANCE_BRAVO_ADDRESSES,
  TIMELOCK_ADDRESSES,
  MERKLE_DISTRIBUTOR_ADDRESS,
  ARGENT_WALLET_DETECTOR_ADDRESS,
  QUOTER_ADDRESSES,
  NONFUNGIBLE_POSITION_MANAGER_ADDRESSES,
  ENS_REGISTRAR_ADDRESSES,
  SOCKS_CONTROLLER_ADDRESSES,
  TICK_LENS_ADDRESSES,
  MIXED_ROUTE_QUOTER_V1_ADDRESSES,
  SWAP_ROUTER_02_ADDRESSES,
  TradeType,
  Rounding,
  MaxUint256,
  Fraction,
  CurrencyAmount,
  Percent,
  Price,
  NativeCurrency,
  validateAndParseAddress,
  Token,
  WETH9,
  Ether,
  computePriceImpact,
  computeZksyncCreate2Address,
  sortedInsert,
  sqrt
};
//# sourceMappingURL=chunk-V2FKQPFC.js.map
